rem --- Standard Report Options Input
rem --- Program ivc_ib v8.0.0 20Dec2007 (ivc_ib)
rem --- Created by c:\codeport_bbj\adx_codeport.bbj v1.1.5 (12/20/2007 11:55:20)

rem --- AddonSoftware Version 8.0.0 - 01Jan2007
rem --- Copyright BASIS International Ltd.  All Rights Reserved.
rem --- All Rights Reserved

            seterr std_error
            setesc std_error
            enter action$,exclude$,col,row,channels[all],params$[all],options$[all],my_context,i0,first_i0,i0_done,validate,v3

rem --- Retrieve the program path

             pgmdir$=stbl("+dir_pgm",err=*next)

rem --- Retrieve sysinfo data

            sysinfo_template$=stbl("+sysinfo_tpl",err=*next)
            dim sysinfo$:sysinfo_template$
            sysinfo$=stbl("+sysinfo",err=*next)
            milestone=num(stbl("+milestone",err=*next),err=*next)
            firm_id$=sysinfo.firm_id$

rem --- Open/Lock files

            files=5,begfile=1,endfile=files
            dim files$[files],options$[files],ids$[files],templates$[files],channels[files]
            files$[1]="ivm-01",ids$[1]="IVM_ITEMMAST"
            files$[2]="ivs_prodcode",ids$[2]="IVS_PRODCODE"
            files$[3]="ivc_whsecode",ids$[3]="IVC_WHSECODE"
            files$[4]="ivm-15",ids$[4]="IVC_TYPECODE"
            files$[5]="ivs_params",ids$[5]="IVS_PARAMS"
            call pgmdir$+"adc_fileopen.aon",action,begfile,endfile,files$[all],options$[all],
:                                   ids$[all],templates$[all],channels[all],batch,status
            if status goto std_exit
            ivm01_dev=channels[1]
            ivm10_dev=channels[2]
            ivm10c_dev=channels[3]
            ivm15_dev=channels[4]
            ivs01a_dev=channels[5]

rem --- Dimension string templates

            dim ivm01a$:templates$[1],ivm10a$:templates$[2],ivm10c$:templates$[3],
:           ivm15a$:templates$[4],ivs01a$:templates$[5]

rem --- Retrieve parameter records

            ivs01a_key$=firm_id$+"IV00"
            find record (ivs01a_dev,key=ivs01a_key$,err=std_missing_params) ivs01a$

rem --- Parameters

            dim i[3],files[14],fields$(8,"Y")
            i2$=params$[2]
            i3$=params$[3],i[0]=num(i2$(1,2)),firm_id$=params$[0]
            i[1]=num(i2$(9,2))
            i[2]=num(i2$(11,2)),i[3]=num(i2$(13,2))

rem --- Initializations

            addr pgm(-2),err=*next
            dim o[7],a0$(22),a1$(60),x0$(32),y0$(5),y1$(20); rem escape , literals$[7]
            files[1]=channels[1]
            files[14]=channels[14],i0_nonkey1=0
            ivm01_dev=channels[1]
            ivm10_dev=channels[10],ivm15_dev=channels[15]
            v5$="Enter the "
            v6$=" to include on this report "
            v7$="(<F1>=First/<F3>=Lookup)"
            v8$="(<F1>=Last/<F3>=Lookup)"
            more=1
            nextfield=0
            BgVal=0
            EndVal=0
            BgProd=0
            End_Prod=0
            BgIVal=0
            EndIVal=0
            BgIType=0

rem --- escape let literals$[0] = "Detail Level", literals$[7] = "Item Type
rem --- escape let literals$[1] = "Beginning Warehouse", literals$[2] = "Ending Warehouse
rem --- escape let literals$[3] = "Beginning Product", literals$[4] = "Ending Product
rem --- escape let literals$[5] = "Beginning Item", literals$[6] = "Ending Item

            if pos("D"=exclude$) then let fields$(1,1)="N"
            if pos("W"=exclude$) then let fields$(2,2)="NN"
            if pos(options$[0]="IW")=0 then let options$[0]="W"
            if i0<first_i0 call pgmdir$+"syc_fe.bbx",911; rem i0 can't be less than first_i0

rem --- Row positions

            lines=pos("L"=action$)<>0
            o[0]=row
            for i=1 to 3
                o[i]=o[i-1]+1+lines
            next i
            if fields$(1,1)="N" then let o[1]=o[1]-1-lines,o[2]=o[2]-1-lines,o[3]=o[3]-1-lines
            if fields$(2,1)="N" then let o[3]=o[3]-2-(lines*2)
            for i=4 to 7
                o[i]=o[i-1]+1+lines
            next i

rem --- Background (not used, setup in arc files)
rem --- escape, if pos( "B"=action$ )=0 then goto set_wh
rem --- escape, for i = 0 to 7
rem --- escape,   if fields$( i+1, 1 )="N" then continue
rem --- escape,   print 'sb', @( 38-len( literals$[i] ), o[i] ), literals$[i], ":", 'sf',
rem --- escape,   if lines then call pgmdir$+"syc_wc.bbx", 1, 0, 80, 0, 0, o[i]+1, 0
rem --- escape, next i


rem This loop is created to transfer control to label:flow_control (Main Loop)

    while more

        set_wh: rem --- Set warehouse fields if not multi-warehouse

            if ivs01a.MULTI_WHSE$<>"Y" then
                rem x0$(1)=firm_id$+"C"+i3$(6,2)
                ivm10c.FIRM_ID$=firm_id$
                ivm10c.RECORD_ID_C$="C"
                ivm10c.WAREHOUSE_ID$=ivs01a.WAREHOUSE_ID$
                options$[1]="",options$[2]=""
                find (ivm10_dev,key=ivm10c.FIRM_ID$+ivm10c.RECORD_ID_C$+ivm10c.WAREHOUSE_ID$,dom=init_display)
                options$[1]=ivs01a.WAREHOUSE_ID$
                options$[2]=ivs01a.WAREHOUSE_ID$
            endif

        init_display: rem --- Display

            if pos("D"=action$) then gosub display_fields
            if pos("I"=action$)=0 then
                goto std_exit
            endif
            nextfield=1
            break

        detail_lvl: rem --- Detail Level

            if fields$(1,1)<>"N" then
                v4$="Enter the detail level for this report (I=by Item/W=by Warehouse)"
                v0$="S"
                v1$="C^",v2$=options$[0],v3$="IW",v0=1,v1=col,v2=o[0],i0=0,control_id=3000+i0
                gosub std_input
                on v3 goto Detail_Level,detail_lvl,Break_2_FC,detail_lvl,Break_2_FC,Detail_Level,Break_2_FC

        Detail_Level:
                options$[0]=v$
                gosub display_level
                if v$<>"W" then
                    rem --- Reset beginning/ending warehouse if item level is selected
                    v$=""
                    options$[1]=v$,x$="First",v2=o[1],control_id=first_i0+1
                    gosub display_warehouse
                    v$=""
                    options$[2]=v$,x$="Last",v2=o[2],control_id=first_i0+2
                    gosub display_warehouse
                endif
            endif

        Break_2_FC:
            rem goto flow_control
            break

            rem --- sub loop starts (Beginning Warehouse)
            while more
                BgVal=0
        beg_wh: rem --- Beginning Warehouse

                    if fields$(2,1)="N" or ivs01a.MULTI_WHSE$<>"Y" or (fields$(1,1)="Y" and options$[0]="I") then
                        rem goto Brk_2_F_C - transfer control to label:flow_control
                        break
                    endif
                    v4$=v5$+"Beginning Warehouse to include "+v7$
                    x$="First",control_id=3000+i0
                    v0$="S"
                    v1$="C",v2$=options$[1],v3$="",v0=2,v1=col,v2=o[1]
                    gosub std_input
                    on v3 goto Check_BgWhse,Bg_Whse,Brk_2_F_C,Begin_Whse,Brk_2_F_C,Check_BgWhse,Brk_2_F_C

        Bg_Whse:
                    v$=""
                    rem goto Check_BgWhse
                    BgVal=1

        Begin_Whse:
                    if BgVal=0
                        call pgmdir$+"ivc_lk.bbx",3,v1,v2,v$
                    endif

        Check_BgWhse: rem --- Check WH

                    v3=0
                    gosub display_warehouse
                    if status then
                        continue
                    endif
                    if options$[2]<>"" and v$>options$[2] then
                        continue
                    endif
                    options$[1]=v$
                    break
            wend
            rem  --- sub loop ends (Beginning Warehouse)

    Brk_2_F_C:
            rem goto flow_control
            break


            rem sub loop starts (Ending Warehouse)

            while more
                EndVal=0
    end_wh: rem --- Ending Warehouse
                    if fields$(3,1)="N" or ivs01a.MULTI_WHSE$<>"Y" then
                        break
                    endif
                    if fields$(1,1)="Y" and options$[0]="I" then
                        break
                    endif
                    v4$=v5$+"Ending Warehouse"+v6$+v8$
                    x$="Last",control_id=3000+i0
                    v0$="S"
                    v1$="C",v2$=options$[2],v3$="",v0=2,v1=col,v2=o[2]
                    gosub std_input
                    on v3 goto Check_EndWhse,End_Whse,Break_To_FC,E_WareHouse,Break_To_FC,Check_EndWhse,Break_To_FC

    End_Whse:
                    v$=""
                    rem goto Check_EndWhse
                    EndVal=1

    E_WareHouse:
                    if EndVal=0
                        call pgmdir$+"ivc_lk.bbx",3,v1,v2,v$
                    endif

    Check_EndWhse: rem --- Check WH

                    v3=0
                    gosub display_warehouse
                    if status then
                        continue
                    endif
                    if v$<>"" and options$[1]>v$ then
                        continue
                    endif
                    options$[2]=v$
                    break
            wend
            rem --- sub loop ends (Ending Warehouse)

    Break_To_FC:
            rem goto flow_control
            break


            rem --- sub loop starts (Begining Product)

            while more

                BgProd=0
    beg_prod: rem --- Beginning Product

                    v4$=v5$+"Beginning Product"+v6$+v7$
                    x$="First",control_id=3000+i0
                    v0$="S"
                    v1$="C",v2$=options$[3],v3$="",v0=3,v1=col,v2=o[3]
                    gosub std_input
                    on v3 goto Check_BgProd,Bg_Prod,Break_To_FlowControl,Bg_Product,Break_To_FlowControl,Check_BgProd,Break_To_FlowControl

    Bg_Prod:
                    v$=""
                    rem goto Check_BgProd
                    BgProd=1

    Bg_Product:
                    if BgProd=0
                        call pgmdir$+"ivc_lk.bbx",1,v1,v2,v$
                    endif

    Check_BgProd: rem --- Check Product

                    v3=0
                    gosub display_product
                    if status then
                        continue
                    endif
                    if options$[4]<>"" and v$>options$[4] then
                        continue
                    endif
                    options$[3]=v$
                    break
            wend
            rem sub loop ends (Begining Product)

    Break_To_FlowControl:
            rem goto flow_control
            break


rem sub loop (Ending Product)

            while more
                End_Prod=0

    end_prod: rem --- Ending Product

                    v4$=v5$+"Ending Product"+v6$+v8$
                    x$="Last",control_id=3000+i0
                    v0$="S"
                    v1$="C",v2$=options$[4],v3$="",v0=3,v1=col,v2=o[4]
                    gosub std_input
                    on v3 goto Check_EndProduct,End_product,Break_To_F_Control,E_Product,Break_To_F_Control,Check_EndProduct,Break_To_F_Control

    End_product:
                    v$=""
                    rem goto Check_EndProduct
                    End_Prod=1

                E_Product:
                    if End_Prod=0
                        call pgmdir$+"ivc_lk.bbx",1,v1,v2,v$
                    endif

                Check_EndProduct: rem --- Check Product

                    v3=0
                    gosub display_product
                    if status then
                        continue
                    endif
                    if v$<>"" and options$[3]>v$ then
                        continue
                    endif
                    options$[4]=v$
                    break
            wend
            rem sub loop ends (Ending Product)

    Break_To_F_Control:  rem goto flow_control
            break

            rem sub loop starts (Begining Item)
            while more
                BgIVal=0
                beg_item: rem --- Beginning Item

                    v1=col
                    v2=o[5],v2$=options$[5],v4$=v5$+"Beginning Item"+v6$,control_id=3000+i0
                    call pgmdir$+"ivc_ia.bbx","F",v1,v2,files[all],firm_id$,v2$,v4$,i[all],item$[all],item[all],v3,i0,i0_done,validate,parent_context,event$
                    on v3 goto BegItem,Bg_Item,Break_2_F_Control,beg_item,Break_2_F_Control,BegItem,Break_2_F_Control

                Bg_Item:
                    v$=""
                    rem goto Check_BgItem
                    BgIVal=1

                BegItem:
                    if BgIVal=0
                        v$=item$[0]
                    endif

                Check_BgItem: rem --- Check Item

                    v3=0
                    x$="First"
                    gosub display_item
                    if status then
                        continue
                    endif
                    if options$[6]<>"" and v$>options$[6] then
                        continue
                    endif
                    options$[5]=v$
                    break
            wend
            rem sub loop ends (Begining Item)

        Break_2_F_Control:
            rem goto flow_control
            break

            rem sub loop starts (Ending Item)
            while more
                EndIVal=0
                end_item: rem --- Ending Item

                    v1=col
                    v2=o[6],v2$=options$[6],v4$=v5$+"Ending Item"+v6$,control_id=3000+i0
                    call pgmdir$+"ivc_ia.bbx","L",v1,v2,files[all],firm_id$,v2$,v4$,i[all],item$[all],item[all],v3,i0,i0_done,validate,parent_context,event$
                    on v3 goto E_Item,Ed_Item,Break_2_Flow_C,end_item,Break_2_Flow_C,E_Item,Break_2_Flow_C

                Ed_Item:
                    v$=""
                    rem goto Check_EndItem
                    EndIVal=1

                E_Item:
                    if EndIVal=0
                        v$=item$[0]
                    endif

                Check_EndItem: rem --- "     Check Item

                    v3=0
                    x$="Last"
                    gosub display_item
                    if status then
                        continue
                    endif
                    if v$<>"" and options$[5]>v$ then
                        continue
                    endif
                    options$[6]=v$
                    break
            wend
            rem sub loop ends (Ending Item)

        Break_2_Flow_C: rem goto flow_control
            break

        rem sub loop starts (Item Type)
        while more
                BgIType=0
                type: rem --- Item Type

                    v4$="Enter a selected item type"+v6$+"(<F1>=All/<F3>=Lookup)"
                    control_id=3000+i0
                    v0$="S"
                    v1$="C",v2$=options$[7],v3$="",v0=3,v1=col,v2=o[7]
                    gosub std_input
                    on v3 goto Check_I_Type,I_Type,Break_To_Flow_Control,Item_Type,Break_To_Flow_Control,Check_I_Type,Break_To_Flow_Control

                I_Type:
                    v$=""
                    rem goto Check_I_Type
                    BgIType=1

                Item_Type:
                    if BgIType=0
                        call pgmdir$+"ivc_lk.bbx",6,v1,v2,v$
                    endif

                Check_I_Type: rem --- Check Type

                    v3=0
                    if v$<>"" then let v$=pad(v$,v0)
                    gosub display_type
                    if status then
                        continue
                    endif
                    options$[7]=v$
                    break
        wend
        rem sub loop Ends (Item Type)

            Break_To_Flow_Control:
            rem goto flow_control
            break
    wend
    rem Main Loop Ends


    if nextfield=0

        flow_control: rem --- Flow Control
            rem goto done; rem only do one field at a time, let caller control flow
            goto std_exit
    endif


    next_field:
        on i0-first_i0 goto detail_lvl,beg_wh,end_wh,beg_prod,end_prod,beg_item,end_item,type,done

    done: rem --- All done
         goto std_exit

    display_fields: rem --- Display fields

        orig_i0=i0
        v$=options$[0],i0=first_i0
        gosub display_level
        i0=i0+1
        v$=options$[1],v2=o[1],x$="First"
        gosub display_warehouse
        i0=i0+1
        v$=options$[2],v2=o[2],x$="Last"
        gosub display_warehouse
        i0=i0+1
        v$=options$[3],v2=o[3],x$="First"
        gosub display_product
        i0=i0+1
        v$=options$[4],v2=o[4],x$="Last"
        gosub display_product
        i0=i0+1
        v$=options$[5],v2=o[5],x$="First"
        gosub display_item
        i0=i0+1
        v$=options$[6],v2=o[6],x$="Last"
        gosub display_item
        i0=i0+1
        v$=options$[7]
        gosub display_type
        i0=orig_i0
        return

    display_level: rem --- Detail Level

        if fields$(1,1)<>"N" then
            x$="(By Item)"
            if v$="W" then let x$="(By Warehouse)"
            call pgmdir$+"syc_rs.bbx","",my_context,3000+i0,v$,0,"",ignore_status
            call pgmdir$+"syc_rs.bbx","",my_context,13000+i0,x$,0,"",ignore_status
        endif
        return

    display_warehouse: rem --- Warehouse

        if fields$(2,1)<>"N" then
            status=0
            if v$<>"" then
                status=1
                rem x0$(1)=firm_id$+"C"+v$
                ivm10c.FIRM_ID$=firm_id$
                ivm10c.RECORD_ID_C$="C"
                ivm10c.WAREHOUSE_ID$=v$
                find record (ivm10_dev,key=ivm10c.FIRM_ID$+ivm10c.RECORD_ID_C$+ivm10c.WAREHOUSE_ID$,dom=Disp_Whse) ivm10c$
                status=0
                v$=ivm10c.WAREHOUSE_ID$
                x$=ivm10c.SHORT_NAME$
            endif
                call pgmdir$+"syc_rs.bbx","",my_context,3000+i0,v$,0,"",ignore_status

            Disp_Whse:
                call pgmdir$+"syc_rs.bbx","",my_context,13000+i0,x$,0,"",ignore_status
        endif
        return



    display_product: rem --- Product

        status=0
        if v$<>"" then
            x$=""
            status=1
            rem x0$(1)=firm_id$+"A"+v$
            ivm10a.FIRM_ID$=firm_id$
            ivm10a.RECORD_ID_A$="A"
            ivm10a.PRODUCT_TYPE$=v$
            find record (ivm10_dev,key=ivm10a.FIRM_ID$+ivm10a.RECORD_ID_A$+ivm10a.PRODUCT_TYPE$,dom=Disp_Prdt) ivm10a$
            status=0
            v$=ivm10a.PRODUCT_TYPE$
            x$=ivm10a.CODE_DESC$
        endif
            call pgmdir$+"syc_rs.bbx","",my_context,3000+i0,v$,0,"",ignore_status
        Disp_Prdt:
            call pgmdir$+"syc_rs.bbx","",my_context,13000+i0,x$,0,"",ignore_status
        return

    display_item: rem --- Item

        status=0
        if v$<>"" then
            x$=""
            status=1
            rem a0$(1)=firm_id$+v$
            ivm01a.FIRM_ID$=firm_id$
            ivm01a.ITEM_ID$=v$
            find record (ivm01_dev,key=ivm01a.FIRM_ID$+ivm01a.ITEM_ID$,dom=Disp_Item) ivm01a$
            status=0
            v$=ivm01a.ITEM_ID$(3,i[0])
            x$=fnitem$(ivm01a.ITEM_DESC$,i[1],i[2],i[3])
        endif
            call pgmdir$+"syc_rs.bbx","",my_context,3000+i0,v$,0,"",ignore_status
        Disp_Item:
            call pgmdir$+"syc_rs.bbx","",my_context,13000+i0,x$,0,"",ignore_status
        return

    display_type: rem --- Item Type

        x$="All"
        rem y0$(1)=firm_id$+v$,y1$(1)="",status=0
        ivm15a.FIRM_ID$=firm_id$
        ivm15a.ITEM_TYPE$=v$
        ivm15a.CODE_DESC$=""
        status=0
        if v$<>"" then
            status=1
            find record (ivm15_dev,key=ivm15a.FIRM_ID$+ivm15a.ITEM_TYPE$,dom=Disp_Type) ivm15a$
            status=0
        Disp_Type: rem --- let x$=y0$(3)
            x$=ivm15a.CODE_DESC$
        endif
            call pgmdir$+"syc_rs.bbx","",my_context,3000+i0,v$,0,"",ignore_status
            call pgmdir$+"syc_rs.bbx","",my_context,13000+i0,x$,0,"",ignore_status
        return

rem #include std_functions.src
rem --- Standard AddonSoftware functions (01Mar2006)
rem --- Functions used to retrieve form values

    def fnstr_pos(q0$,q1$,q1)=int((pos(q0$=q1$,q1)+q1-1)/q1)
    def fnget_rec_date$(q0$)=rd_rec_data$[fnstr_pos(cvs(q0$,1+2+4)+"."+
:                            cvs(q0$,1+2+4),rd_rec_data$[0,0],40),0]
    def fnget_fld_data$(q0$,q1$)=cvs(rd_rec_data$[fnstr_pos(cvs(q0$,1+2+4)+"."+
:                                cvs(q1$,1+2+4),rd_rec_data$[0,0],40),0],2)
    def fnget_table$(q0$)=rd_alias_id$

rem --- Miscellaneous functions

    def fncenter(q$,q)=int((q-len(q$))/2)

rem --- Format inventory item description

    def fnitem$(q$,q1,q2,q3)=cvs(q$(1,q1)+" "+q$(q1+1,q2)+" "+q$(q1+q2+1,q3),32)

rem --- Date/time handling functions

    def fnyy$(q$)=q$(3,2)
    def fnclock$(q$)=date(0:"%hz:%mz %p")
    def fntime$(q$)=date(0:"%Hz%mz")

rem --- fnmask$: Alphanumeric Masking Function (formerly fnf$)

    def fnmask$(q1$,q2$)
        if q2$="" q2$=fill(len(q1$),"0")
        return str(-num(q1$,err=*next):q2$,err=*next)
        q=1
        q0=0
        while len(q2$(q))
              if pos(q2$(q,1)="-()") q0=q0+1 else q2$(q,1)="X"
              q=q+1
        wend
        if len(q1$)>len(q2$)-q0 q1$=q1$(1,len(q2$)-q0)
        return str(q1$:q2$)
    fnend

rem --- fnbasename$: Strip path and optionally the suffix from a file name

    def fnbasename$(q$,q0$)
        q=max(pos("/"=q$,-1),pos(":"=q$,-1),pos(">"=q$,-1),pos("\"=q$,-1))
        if q then q$=q$(q+1)
        if q0$<>"" then q=mask(q$,q0$); if q q$=q$(1,q-1)
    return q$

rem --- fnglobal: Return numeric value of passed stbl variable

    def fnglobal(q$,q1)
        q1$=stbl(q$,err=*next),q1=num(q1$,err=*next)
        return q1
    fnend

rem --- fnglobal$: Return string value of passed STBL variable

    def fnglobal$(q$,q1$)
        q1$=stbl(q$,err=*next)
        return q1$
    fnend

rem #endinclude std_functions.src

rem --- #include "./aon/lib/std_input.src

std_input: rem --- standard input routine (12-mar-2003)

    if restart and vaction$="s" then let vaction$="sp",restart=0
    if vaction$="g" then let compare_control=num(str(grid_id)+str(grid_row:"000")+str(grid_col:"000")) else let compare_control=control_id
    if compare_control=old_control_id then let validate=0 else let old_control_id=compare_control
    dim vdata$[10],vdata[10],vinfo$[20],vinfo[20]
    let vdata$[0]=v0$,vdata$[1]=v1$,vdata$[2]=v2$,vdata$[3]=v3$,vdata$[4]=v4$
    let vdata[0]=v0,vdata[1]=v1,vdata[2]=v2,vdata[3]=v3,vdata[4]=v
    let vinfo$[0]=pgm(-2),vinfo$[4]=event$,vinfo[2]=control_id,vinfo[3]=i0
    let vinfo[4]=i0_nonkey1,vinfo[5]=i0_done,vinfo[6]=my_context
    let vinfo[7]=validate,vinfo[8]=statusbar_context,vinfo[9]=parent_context
    let vinfo[10]=tab_control_id,vinfo[11]=tab_index,vinfo[12]=done_context
    let vinfo[14]=grid_col,vinfo[15]=grid_row
    let vinfo$[11]=vtoken1$,vinfo$[12]=vtoken2$,vinfo$[13]=vtoken3$
    let vinfo$[14]=vtoken4$,vinfo$[15]=vtoken5$,vinfo$[16]=vtoken6$
    let vinfo$[17]=vtoken7$,vinfo$[18]=vtoken8$,vinfo$[19]=vtoken9$

rem --- call standard input routine
    call pgmdir$+"syc_ig.bbx",vaction$,vdata$[all],vdata[all],vinfo$[all],vinfo[all],vmenu$[all],vmenu[all],vtool$[all],vtool[all],vstatus
    if vstatus=127 then goto std_input_escape
    if vstatus=999 then goto std_input_error
    goto std_input_exit
std_input_escape: rem --- escape during input
    call pgmdir$+"syc_es.bbx",err=std_input_error,pgm(-2),tcb(8),e$,e2,v3
    if v3<>127 then goto std_input
    print @(0,e2),'cl','cursor'("ON"),e$,'lf'
std_input_error: rem --- error during input
    escape
    goto std_input
std_input_exit: rem --- assign local variables and return
    let v$=vinfo$[1],event$=vinfo$[4],v=vinfo[0],v3=vinfo[1]
    let next_control=vinfo[2],i0=vinfo[3],next_context=vinfo[6]
    let validate=vinfo[7],grid_col=vinfo[14],grid_row=vinfo[15]
    let wants_to_edit_cell=vinfo[16],next_tab_index=vinfo[18]
    if wants_to_edit_cell then dim vnotice$:vinfo$[3]; let vnotice$=vinfo$[2]
    return

rem --- #end include
rem #include std_error.src

std_error: rem --- Standard error handler (01Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    call stbl("+DIR_SYP")+"bac_error.bbj",err=std_error_exit,pgm(-2),str(tcb(5):"00000"),
:                                str(err:"000"),rd_err_text$,rd_err_act$
    if pos("EXIT"=rd_err_act$) goto std_error_exit
    if pos("ESCAPE"=rd_err_act$) seterr 0;setesc 0
    if pos("RETRY"=rd_err_act$) retry
std_error_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_error_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_error_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_error_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_error_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_error.src
rem #include std_missing_params.src

std_missing_params: rem --- Standard missing parameter handler (15Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    pgmdir$=stbl("+DIR_PGM",err=std_missing_params_exit)
    call pgmdir$+"adc_noparams.aon",err=std_missing_params_exit,pgm(-2),str(tcb(5):"00000"),
:                                   str(err:"000"),rd_err_text$,rd_err_act$
std_missing_params_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_missing_params_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_missing_params_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_missing_params_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_missing_params_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_missing_params.src

rem #include std_exit.src

std_exit: rem --- Standard called program exit (01Mar2006)

    exit
rem #endinclude std_exit.src

    end
