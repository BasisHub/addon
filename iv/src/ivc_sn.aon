rem --- Generate Lot/Serial Numbers
rem --- Program ivc_sn v8.0.0 05Dec2007 (ivc_sn)
rem --- Created by c:\codeport_bbj\adx_codeport.bbj v1.1.5 (12/05/2007 10:20:37)

rem --- AddonSoftware Version 8.0.0 - 01Jan2007
rem --- Copyright (c) 1981-2007 AddonSoftware
rem --- All Rights Reserved

        seterr std_error
        setesc std_exit
        enter sys01_dev,row,quantity,serial$[all],status

rem --- Retrieve the program path

         pgmdir$=stbl("+dir_pgm",err=*next)

rem --- Retrieve sysinfo data

        sysinfo_template$=stbl("+sysinfo_tpl",err=*next)
        dim sysinfo$:sysinfo_template$
        sysinfo$=stbl("+sysinfo",err=*next)
        milestone=num(stbl("+milestone",err=*next),err=*next)
        firm_id$=sysinfo.firm_id$

rem --- Open/Lock files

        files=1,begfile=1,endfile=files
        dim files$[files],options$[files],ids$[files],templates$[files],channels[files]
        files$[1]="ivs_params",ids$[1]="IVS_PARAMS"
        call pgmdir$+"adc_fileopen.aon",action,begfile,endfile,files$[all],options$[all],
:                                   ids$[all],templates$[all],channels[all],batch,status
        if status goto std_exit
        ivs01a_dev=channels[1]

rem --- Dimension string templates

        dim ivs01a$:templates$[1]

rem --- Retrieve parameter records

        ivs01a_key$=firm_id$+"IV00"
        find record (ivs01a_dev,key=ivs01a_key$,err=std_missing_params) ivs01a$

rem --- Determine interface

        call pgmdir$+"syc_dg.bbx",sysgui_dev,event$,event_len,sysfin$,sysfin,ui$,status
        if status then goto std_exit
        if ui$="W" then let orig_context=sysfin.current_context

rem --- Parameters

        dim p[3],t$:stbl("+TASK_TMPL")
        t$=stbl("+TASK")
        firm_id$=t.f0$(16,2),status=1
        find record (sys01_dev,key=firm_id$+"IV00",dom=std_missing_params) ivs01a$
        if pos(p3$(17,1)="SL")=0 then goto std_exit
        p[3]=num(p2$(7,2))

rem --- Initializations

        status=0
        m2$="#,##0",title$="Generate Lot/Serial Numbers"
        height=6
        win_y=max(row-height-2,2),width=46+p[3]
        win_x=int((80-width)/2)
        number=quantity,name$=""
        more=1

rem --- Background

    if ui$<>"W" then call pgmdir$+"syc_wa.bbx",0,width,height,win_x,win_y,title$,name$
    dim resparams$[20],resparams[20]
    resparams$[0]=pgm(-2)
    resparams$[6]=title$
    call pgmdir$+"syc_ra.bbx","P",resparams$[all],resparams[all],vmenu$[all],vmenu[all],vtool$[all],vtool[all],status
    if status then goto std_exit
    rem gosub flow_initializations

    ls_no: rem --- Lot/Serial Number

        v0$="S"
        v1$="CERK",v2$=ser$,v3$="",v0=p[3],v1=26,v2=0,i0=0
        v4$="Enter The First Lot/Serial Number"
        control_id=3000
        on v3 goto Serial_Number,ls_no,To_F_Control,ls_no,To_F_Control,Serial_Number,To_F_Control
    Serial_Number:
        ser$=v$
    while more
        To_F_Control:
            break
            while more
                qty: rem --- Quantity
                    v0$="N"
                    v1$="C",v2$=str(number),v3$=m2$,v0=7,v1=26,v2=1
                    v4$="Enter The Number Of Lot/Serial Numbers Needed"
                    control_id=3001
                    on v3 goto Quantity_Part,qty,Break_To_FC,qty,Break_To_FC,Quantity_Part,Break_To_FC
                Quantity_Part:
                    if v<1 then
                        continue
                    endif
                    number=v
                    break
            wend
            Break_To_FC: rem break to flow control
            break
    wend
    flow_control: rem --- Flow Control
        switch v3
            case 0
            case 1
            case 3; let i0=i0+1; break
            case 2
            if i0<i0_nonkey1 then let i0=max(0,i0-1) else let i0=max(i0_nonkey1,i0-1)
            break
            case 4; exitto start_done
            case default; exitto done_v3
        swend

    next_field:
        on i0 goto ls_no,qty,done

    start_done: 
             i0=i0_done

    done: rem --- Correct?

        if !validate then
            v0$="Y"
            v1$="KC",v2$="Y",v3$="",v4$="ITAC=Y",v0=6,v1=0,v2=22,control_id=i0-i0_done+1
            done_v3:
                on v3 goto done_test,done,done,done,cancel,validate_input,cancel,done
            done_test:
                on pos(v$="YN") goto flow_control,validate_input,do_nonkey1
            validate_input:
                validate=1
                old_control_id=0
            do_nonkey1:
                v3=0
                i0=i0_nonkey1
                on i0 goto ls_no,qty,done
            cancel:
            goto std_exit
        else
            let validate=0
        endif

    end_input: rem --- Setup Variables

        if number>=1 then
            ser=len(ser$)
            if ser<1 then let ser=len(str(number)),ser$=str(1:fill(ser,"0"))
            dim a$[ser],serial$[number]
            for i=1 to ser
                a$[i]=ser$(i,1)
            next i
            serial$[0]=str(number)
            serial$[1]=ser$,y0=ser
            if number<2 then goto std_exit

rem --- Create Loop

            for i=2 to number
                if y0<1 then exitto no_serial
                while more
                    x0=num(a$[y0],err=errline1)
                    if x0=9 then
                        let a$[y0]="0"
                        y0=y0-1
                        continue
                    else
                        break
                    endif    
                    errline1:
                        y0=y0-1
                        continue
                wend
                a$[y0]=str(x0+1:"0")
                y0=ser

                for j=1 to ser
                    serial$[i]=serial$[i]+a$[j]
                next j
            next i

rem --- All done
            goto std_exit
        endif

        no_serial: rem --- Don't return any serial numbers
        serial$[0]="0"
        goto std_exit

rem --- Return string value of passed STBL variable
        def fnglobal$(q$,q1$)
        let q1$=stbl(q$,err=*next)
        return q1$
        fnend

rem #include std_error.src

std_error: rem --- Standard error handler (01Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    call stbl("+DIR_SYP")+"bac_error.bbj",err=std_error_exit,pgm(-2),str(tcb(5):"00000"),
:                                str(err:"000"),rd_err_text$,rd_err_act$
    if pos("EXIT"=rd_err_act$) goto std_error_exit
    if pos("ESCAPE"=rd_err_act$) seterr 0;setesc 0
    if pos("RETRY"=rd_err_act$) retry
std_error_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_error_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_error_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_error_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_error_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_error.src
rem #include std_missing_params.src

std_missing_params: rem --- Standard missing parameter handler (15Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    pgmdir$=stbl("+DIR_PGM",err=std_missing_params_exit)
    call pgmdir$+"adc_noparams.aon",err=std_missing_params_exit,pgm(-2),str(tcb(5):"00000"),
:                                   str(err:"000"),rd_err_text$,rd_err_act$
std_missing_params_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_missing_params_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_missing_params_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_missing_params_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_missing_params_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_missing_params.src

rem #include std_exit.src

std_exit: rem --- Standard called program exit (01Mar2006)

    exit

rem #endinclude std_exit.src

    end
