rem Generate Executive Summary
rem Program ads_execsummary v8.0.0 04Nov2006 (syx_e*)
rem Created by adx_codeport.bbx v1.1.1 (11/04/2006 10:50:33)

rem --- AddonSoftware Version 8.0.0 - 01Jan2007
rem --- Copyright (c) 1981-2007 AddonSoftware
rem --- All Rights Reserved

rem --- This program replaces the nine overlays used to generate the
rem --- Executive Summary files in previous releases. It is broken up
rem --- into the following sections:

rem --- Program initializations and user dialog
rem --- Determine what applications are installed and open files
rem --- Phase  1: Build list of valid firms and create generation records
rem --- Phase  2: Sales Order Processing (sales and costs)
rem --- Phase  3: Purchase Orders (open purchase orders)
rem --- Phase  4: Accounts Payable (open payables)
rem --- Phase  5: Accounts Receivable (open receivables)
rem --- Phase  6: Inventory (balances)
rem --- Phase  7: Sales Analysis (sales and costs)
rem --- Phase  8: Shop Floor Control (work in process)
rem --- Phase  9: Any customer Executive Summary processing
rem --- Phase 10: Consolidation (totals for all firms)
rem --- Subroutines and functions

rem ---------------------------------------------------------------------
rem --- Program initializations and user dialog
rem ---------------------------------------------------------------------

rem seterr std_error
rem setesc std_error

rem --- Retrieve the program path

    pgmdir$=stbl("+DIR_PGM",err=*next)
    dirsyp$=stbl("+DIR_SYP",err=*next)

rem --- Retrieve sysinfo data

    sysinfo_template$=stbl("+SYSINFO_TPL",err=*next)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=*next)
    task_description$=cvs(sysinfo.task_desc$,2)

rem --- Debug is used to provide diagnostics for debugging any problems.

rem --- Valid values are:
rem --- 0 = No diagnostics
rem --- 1 = Show syswindow and prompt at phase entry/exit

    debug=0;rem cah
    if debug print 'show'

rem --- Open/Lock files

    num_files=3
    dim open_tables$[1:num_files],open_opts$[1:num_files],open_chans$[1:num_files],open_tpls$[1:num_files]
    open_tables$[1]="ADM_MODULES",open_opts$[1]="OTA"
    open_tables$[2]="ADM_FIRMS",open_opts$[2]="OTA"
    open_tables$[3]="IVS_PARAMS",open_opts$[3]="OTA"

    gosub open_tables

    adm04_dev=num(open_chans$[1]);dim adm04a$:open_tpls$[1]
    adm06_dev=num(open_chans$[2]);dim adm06a$:open_tpls$[2]
    ivs_params_dev=num(open_chans$[3]);dim ivs_params$:open_tpls$[3]


rem --- Dimension string templates


rem --- Initializations

    dim info$[20]
    firms$=""
    generation_date$=sysinfo.system_date$
    clock$=date(0:"%Hz%mz%sz")
    yyyy$=generation_date$(1,4)
    mm$=generation_date$(5,2)
    dd$=generation_date$(7,2)
    days=31

    milestone=20,milestone=num(stbl("+MILESTONE",err=*next),err=*next)

    groupSpace!=BBjAPI().getGroupNamespace()
    task_id$="GEN_EXECSUMM"

rem --- Flag values

    more=1
    morefirms=1
    moreheaders=1
    return_values=1
    update_values=2
    using_units=0
    using_lines=0

rem --- LAST$ is the latest (furthest in the future) sales order ship date
rem --- or purchase order receipt date. It's used in inventory processing 
rem --- to determine how far out inventory records need to be created

    last$=generation_date$

rem --- Get user approval to proceed

    msg_id$="AON_RUN_QUERY"
    dim x$:Stbl("+SYSINFO_TPL")
    dim msg_tokens$[1]
    x$=stbl("+SYSINFO")                                                            
    msg_tokens$[1]=x.task_desc$+" as of "+fndate$(generation_date$)
    gosub disp_message
    if msg_opt$<>"Y" then goto std_exit

rem ---------------------------------------------------------------------
rem --- Determine what applications are installed and open files
rem ---------------------------------------------------------------------

rem --- NOTE: There are additional file opens in the Inventory section
rem --- based on parameter settings (lot/serialized, LIFO/FIFO, etc.)

rem --- Start up the progress meter

    phase$="Initializations"
    channel=adm06_dev

rem --- Determine what applications are installed

    application$="AP"
    gosub installed
    ap=installed

    application$="AR"
    gosub installed
    ar=installed

    application$="IV"
    gosub installed
    iv=installed

    application$="ARIVOP"
    gosub installed
    op=installed

    application$="APPO"
    gosub installed
    po=installed

    application$="ARIVOPSA"
    gosub installed
    sa=installed

    application$="IVSF"
    gosub installed
    sf=installed
    sf=0;rem *********************** Remove to Activate

rem --- Any custom executive summary processing?

    custom=0

rem --- Open executive summary files. Any custom files should be added to the bottom
rem --- of the list. The remaining application file opens/templates will be adjusted
rem --- based on the value of endfile.

    files=10,begfile=1,endfile=files,summary_files=files
    dim files$[files],options$[files],ids$[files],templates$[files],channels[files]
    dim summary_files$[files],summary_channels[files]
    files$[1]="ade-01",ids$[1]="ADE_EXECGEN"
    files$[2]="ade-02",ids$[2]="ADE_EXECAR"
    files$[3]="ade-03",ids$[3]="ADE_EXECAP"
    files$[4]="ade-04",ids$[4]="ADE_EXECSALE"
    files$[5]="ade-05",ids$[5]="ADE_EXECCOST"
    files$[6]="ade-06",ids$[6]="ADE_EXECPO"
    files$[7]="ade-07",ids$[7]="ADE_EXECSTOT"
    files$[8]="ade-08",ids$[8]="ADE_EXECCTOT"
    files$[9]="ade-09",ids$[9]="ADE_EXECIV"
    files$[10]="ade-10",ids$[10]="ADE_EXECWIP"
    for x=1 to endfile
        options$[x]="CL"
        summary_files$[x]=files$[x]
    next x

rem --- Open the required files and retrieve the templates

    call pgmdir$+"adc_fileopen.aon",action,begfile,endfile,files$[all],options$[all],
:                                   ids$[all],templates$[all],channels[all],batch,status
    if status goto std_exit
    ade01_dev=channels[1]
    ade02_dev=channels[2]
    ade03_dev=channels[3]
    ade04_dev=channels[4]
    ade05_dev=channels[5]
    ade06_dev=channels[6]
    ade07_dev=channels[7]
    ade08_dev=channels[8]
    ade09_dev=channels[9]
    ade10_dev=channels[10]

    rem --- Save executive summary file channels for consolidation phase

    for x=1 to summary_files
        summary_channels[x]=channels[x]
    next x

    rem --- Which files require consolidation based on installed applications

    dim used[files]
    used[1]=1
    used[2]=ar
    used[3]=ap
    used[4]=op
    used[5]=op
    used[6]=po
    used[7]=sa
    used[8]=sa
    used[9]=iv
    used[10]=sf

rem --- Dimension executive summary string templates

    dim ade01a$:templates$[1],ade02a$:templates$[2],ade03a$:templates$[3],
:       ade04a$:templates$[4],ade05a$:templates$[5],ade06a$:templates$[6],
:       ade07a$:templates$[7],ade08a$:templates$[8],ade09a$:templates$[9],
:       ade10a$:templates$[10]

rem --- Generate list of application files to be opened based on what's installed

    files=17,begfile=1,endfile=files
    dim files$[files],options$[files],ids$[files],templates$[files],channels[files]
    if ap
        files$[1]="apt-01",ids$[1]="APT_INVOICEHDR"
        files$[2]="apt-11",ids$[2]="APT_INVOICEDET"
    endif
    if ar
        files$[3]="art-01",ids$[3]="ART_INVHDR"
        files$[4]="art-11",ids$[4]="ART_INVDET"
    endif
    if iv
        files$[5]="ivm-01",ids$[5]="IVM_ITEMMAST"
        files$[6]="ivm-02",ids$[6]="IVM_ITEMWHSE"
        files$[7]="ivt-04",ids$[7]="IVT_ITEMTRAN"
    endif
    if op
        files$[8]="ope-01",ids$[8]="OPE_ORDHDR"
        files$[9]="ope-11",ids$[9]="OPE_ORDDET"
        files$[10]="opm-02",ids$[10]="OPC_LINECODE"
    endif
    if po
        files$[11]="poe-12",ids$[11]="POE_PODET"
        files$[12]="pom-02",ids$[12]="POC_LINECODE"
    endif
    if sa
        files$[13]="opt-01",ids$[13]="OPT_INVHDR"
    endif
    if sf
        files$[14]="sfe-01",ids$[14]="SFE_WOMASTR"
        files$[15]="sft-01",ids$[15]="SFT_OPNOPRTR"
        files$[16]="sft-21",ids$[16]="SFT_OPNMATTR"
        files$[17]="sft-31",ids$[17]="SFT_OPNSUBTR"
    endif

rem --- Open the required files and retrieve the templates

    call pgmdir$+"adc_fileopen.aon",action,begfile,endfile,files$[all],options$[all],
:                                   ids$[all],templates$[all],channels[all],batch,status
    if status goto std_exit
    apt01_dev=channels[1]
    apt11_dev=channels[2]
    art01_dev=channels[3]
    art11_dev=channels[4]
    ivm01_dev=channels[5]
    ivm02_dev=channels[6]
    ivt04_dev=channels[7]
    ope01_dev=channels[8]
    ope11_dev=channels[9]
    opm02_dev=channels[10]
    poe12_dev=channels[11]
    pom02_dev=channels[12]
    opt01_dev=channels[13]
    sfe01_dev=channels[14]
    sft01_dev=channels[15]
    sft21_dev=channels[16]
    sft31_dev=channels[17]

rem --- Dimension application file string templates

    total_recs=0

    if ap
        dim apt01a$:templates$[1]
        dim apt11a$:templates$[2]
        total_table=apt01_dev
        gosub add_to_total
    endif

    if ar
        dim art01a$:templates$[3]
        dim art11a$:templates$[4]
        total_table=art01_dev
        gosub add_to_total
    endif

    if iv
        dim ivm01a$:templates$[5]
        dim ivm02a$:templates$[6]
        dim ivt04a$:templates$[7]
        total_table=ivm01_dev
        gosub add_to_total
    endif

    if op
        dim ope01a$:templates$[8]
        dim ope11a$:templates$[9]
        dim opm02a$:templates$[10]
        total_table=ope01_dev
        gosub add_to_total
    endif

    if po
        dim poe12a$:templates$[11]
        dim pom02a$:templates$[12]
        total_table=poe12_dev
        gosub add_to_total
    endif

    if sa
        dim opt01a$:templates$[13]
        total_table=opt01_dev
        gosub add_to_total
    endif

    if sf
        dim sfe01a$:templates$[14]
        dim sft01a$:templates$[15]
        dim sft21a$:templates$[16]
        dim sft31a$:templates$[17]
        total_table=sfe01_dev
        gosub add_to_total
    endif

rem --- Update progress meter

    GroupSpace!.setValue("+process_task",task_id$+"^C^Generate Executive Summary^^"+str(total_recs)+"^")

rem ---------------------------------------------------------------------
rem --- Phase 1: Build list of valid firms and create generation records
rem ---------------------------------------------------------------------

rem --- Start up the progress meter and position the firm master file

    phase$="Firms"
    channel=adm06_dev
    read (adm06_dev,key="",dom=*next)

rem --- Build list of valid firms

    while morefirms
        k$=key(adm06_dev,end=*break)
        read record (adm06_dev) adm06a$
        firms$=firms$+adm06a.company_id$
        call pgmdir$+"adc_progress.aon","S","","","","",0,0,1,meter_num,status

        rem --- Update ade-01 (Generation Record) for each valid firm

        ade01a.firm_id$=adm06a.company_id$
        ade01a.gen_date$=generation_date$
        ade01a.gen_time$=clock$
        write record (ade01_dev) ade01a$
    wend

rem --- End of phase processing

    firms=len(firms$)

rem ---------------------------------------------------------------------
rem --- Phase 2: Sales Order Processing (sales and costs)
rem ---------------------------------------------------------------------

    while op

        rem --- Start up the progress meter

        phase$="Sales Orders"
        channel=ope01_dev

        rem --- Initializations for Sales Order Processing

        dim a[days],u[days],l[days]
        application$="ARIVOP"
        lastcode$=""
        using_units=1
        using_lines=1
        lines=1

        rem --- For each valid firm

        for firm=1 to firms step 2

            rem --- Is Sales Order Processing installed for this firm?

            firm_id$=firms$(firm,2)
            gosub application_used
            if notused continue

            rem --- Position Sales Order Header file (ope-01)

            read (ope01_dev,key=firm_id$,dom=*next)

            rem --- Read next Sales Order Header record

            while moreheaders
            k$=key(ope01_dev,end=*break)
            if pos(firm_id$=k$)<>1 break
            gosub update_meter
            read record (ope01_dev) ope01a$
            if ope01a.invoice_type$<>"S" continue
            units=1
            order$=ope01a.firm_id$+ope01a.ar_type$+ope01a.customer_id$+
:                               ope01a.order_no$

            rem --- Position Sales Order Detail file (ope-11)

            read (ope11_dev,key=k$,dom=*next)

            rem --- Read next Sales Order Detail record

            while 1
                k$=key(ope11_dev,end=*break)
                if pos(order$=k$)<>1 break
                read record (ope11_dev) ope11a$

                rem --- Retrieve line type

                thiscode$=firm_id$+ope11a.line_code$
                if thiscode$<>lastcode$
	                dim opm02a$:fattr(opm02a$)
	                lastcode$=firm_id$+ope11a.line_code$
	                find record (opm02_dev,key=lastcode$,dom=*next) opm02a$
                endif

                rem --- Determine the estimated date for this sale

                when$=ope11a.est_shp_date$
                if cvs(when$,2)="" when$=ope01a.shipmnt_date$
                if cvs(when$,2)="" when$=ope01a.invoice_date$
                if cvs(when$,2)="" continue
                if when$>last$ last$=when$
                year$=when$(1,4)
                month$=when$(5,2)
                d=num(when$(7,2))

                rem --- Calculate sales and cost amounts

                sale=ope11a.qty_ordered*ope11a.unit_price
                cost=ope11a.qty_ordered*ope11a.unit_cost
                if opm02a.line_type$="O"
	                sale=ope11a.ext_price
	                cost=0
                endif
                if opm02a.line_type$="O" and ope11a.commit_flag$="N" and ope11a.ext_price=0 sale=ope11a.unit_price

                rem --- Update sales record

                dim rec$:fattr(ade04a$)
                amountvar$="ord_amt_ship"
                unitsvar$="no_ord_ship"
                linesvar$="no_lns_ship"
                channel=ade04_dev
                amount=sale
                gosub update_record

                rem --- Update costs record

                dim rec$:fattr(ade05a$)
                amountvar$="ord_cst_ship"
                unitsvar$="no_ord_ship"
                linesvar$="no_lns_ship"
                channel=ade05_dev
                amount=cost
                if amount gosub update_record

                rem --- Loop back for next detail

            wend

            rem --- Loop back for next header

            wend

            rem --- Next firm

        next firm

        rem --- End of phase processing for Sales Order Processing
        break
    wend

rem ---------------------------------------------------------------------
rem --- Phase 3: Purchase Orders (open purchase orders)
rem ---------------------------------------------------------------------

    while po

        rem --- Start up the progress meter

        phase$="Purchase Orders"
        channel=poe12_dev

        rem --- Initializations for Purchase Order Processing

        dim a[days],u[days],l[days]
        application$="APPO"
        lastcode$=""
        using_units=1
        using_lines=0

        rem --- For each valid firm

        for firm=1 to firms step 2

            rem --- Is Purchase Order Processing installed for this firm?

            firm_id$=firms$(firm,2)
            gosub application_used
            if notused continue

            rem --- Position Purchase Order Detail file (poe-12)

            read (poe12_dev,key=firm_id$,dom=*next)

            rem --- Get next Purchase Order Detail record

            while 1
                k$=key(poe12_dev,end=*break)
                if pos(firm_id$=k$)<>1 break
                gosub update_meter
                read record (poe12_dev) poe12a$

                rem --- Retrieve line type

                thiscode$=firm_id$+poe12a.po_line_code$
                if thiscode$<>lastcode$
                    dim pom02a$:fattr(pom02a$)
                    lastcode$=firm_id$+poe12a.po_line_code$
                    find record (pom02_dev,key=lastcode$,dom=*next) pom02a$
                endif

                rem --- Message or Vendor Item Line?

                if pos(pom02a.line_type$="SNO")=0 continue

                rem --- What's the expected receipt date for this purchase?

                when$=poe12a.reqd_date$
                if when$>last$ last$=when$
                year$=when$(1,4)
                month$=when$(5,2)
                d=num(when$(7,2))

                rem --- Calculate purchase amount

                amount=(poe12a.qty_ordered-poe12a.qty_received)*poe12a.unit_cost
                units=1

                rem --- Update purchases record

                dim rec$:fattr(ade06a$)
                amountvar$="po_amt_rec"
                unitsvar$="no_lns_rec"
                channel=ade06_dev
                gosub update_record

            rem --- Loop back for next line item
            wend

        rem --- Next firm
        next firm

        rem --- End of phase processing for Purchase Order Processing
        break
    wend

rem ---------------------------------------------------------------------
rem --- Phase 4: Accounts Payable (open payables)
rem ---------------------------------------------------------------------

    while ap
  
        rem --- Start up the progress meter

        phase$="Payables"
        channel=apt01_dev

        rem --- Initializations for Accounts Payable

        dim a[days],u[days],l[days]
        application$="AP"
        using_units=1
        using_lines=0

        rem --- For each valid firm

        for firm=1 to firms step 2

            rem --- Is Accounts Payable installed for this firm?

            firm_id$=firms$(firm,2)
            gosub application_used
            if notused continue

            rem --- Position Invoice History Header file (apt-01)

            read (apt01_dev,key=firm_id$,dom=*next)

            rem --- Read next Invoice Header (apt-01) record

            while moreheaders
            k$=key(apt01_dev,end=*break)
            if pos(firm_id$=k$)<>1 break
            gosub update_meter
            read record (apt01_dev) apt01a$
            total=apt01a.invoice_amt
            units=1
            invoice$=apt01a.firm_id$+apt01a.ap_type$+apt01a.vendor_id$+apt01a.ap_inv_no$

            rem --- Position Invoice Detail file (apt-11)

            read (apt11_dev,key=invoice$,dom=*next)

            rem --- Read next Invoice Detail (art-11) record
            rem --- and accumulate invoice total

            while 1
                k$=key(apt11_dev,end=*break)
                if pos(invoice$=k$)<>1 break
                read record (apt11_dev) apt11a$
                total=total+apt11a.trans_amt
            wend

            rem --- Determine the estimated receipt date for this invoice

            when$=apt01a.inv_due_date$
            if cvs(when$,2)="" when$=apt01a.invoice_date$
            if cvs(when$,2)="" continue
            year$=when$(1,4)
            month$=when$(5,2)
            d=num(when$(7,2))

            rem --- Update accounts payable record

            dim rec$:fattr(ade03a$)
            amountvar$="inv_due_bydt"
            unitsvar$="no_inv_due"
            channel=ade03_dev
            amount=total
            gosub update_record

            rem --- Loop back for next header
            wend

        rem --- Next firm
        next firm

        rem --- End of phase processing for Accounts Payable
        break
    wend

rem ---------------------------------------------------------------------
rem --- Phase 5: Accounts Receivable (open receivables)
rem ---------------------------------------------------------------------

    while ar

        rem --- Start up the progress meter

        phase$="Receivables"
        channel=art01_dev

        rem --- Initializations for Accounts Receivable

        dim a[days],u[days],l[days]
        application$="AR"
        using_units=1
        using_lines=0

        rem --- For each valid firm

        for firm=1 to firms step 2

            rem --- Is Accounts Receivable installed for this firm?

            firm_id$=firms$(firm,2)
            gosub application_used
            if notused continue

            rem --- Position Invoice History Header file (art-01)

            read (art01_dev,key=firm_id$,dom=*next)

            rem --- Read next Invoice Header (art-01) record

            while moreheaders
            k$=key(art01_dev,end=*break)
            if pos(firm_id$=k$)<>1 break
            gosub update_meter
            read record (art01_dev) art01a$
            total=art01a.invoice_amt
            units=1
            invoice$=art01a.firm_id$+art01a.ar_type$+art01a.customer_id$+art01a.ar_inv_no$

            rem --- Position Invoice Detail file (art-11)

            read (art11_dev,key=invoice$,dom=*next)

            rem --- Read next Invoice Detail (art-11) record
            rem --- and accumulate invoice total

            while 1
                k$=key(art11_dev,end=*break)
                if pos(invoice$=k$)<>1 break
                read record (art11_dev) art11a$
                total=total+art11a.trans_amt+art11a.adjdisc_amt
            wend

            rem --- Determine the estimated receipt date for this invoice

            when$=art01a.inv_due_date$
            if cvs(when$,2)="" when$=art01a.invoice_date$
            if cvs(when$,2)="" continue
            year$=when$(1,4)
            month$=when$(5,2)
            d=num(when$(7,2))

            rem --- Update accounts receivable record

            dim rec$:fattr(ade02a$)
            amountvar$="inv_due_bydt"
            unitsvar$="no_inv_due"
            channel=ade02_dev
            amount=total
            gosub update_record

            rem --- Loop back for next header
            wend

        rem --- Next firm
        next firm

        rem --- End of phase processing for Accounts Receivable
        break
    wend

rem ---------------------------------------------------------------------
rem --- Phase 6: Inventory (balances)
rem ---------------------------------------------------------------------

rem --- Because inventory balances are calculated for the generation date
rem --- and then adjusted into the future based on sales and purchase orders, 
rem --- the updating of the executive summary file is handled locally rather
rem --- than using the the common subroutines that the other applications use.

    while iv

        rem --- Start up the progress meter

        phase$="Inventory"
        channel=ivm01_dev

        rem --- Initializations

        dim a[days],u[days],l[days],change[days]
        application$="IV"
        d=num(dd$)
        m=num(mm$)
        y=num(yyyy$)
        using_units=0
        using_lines=0

        rem --- LAST$ is the latest (furthest in the future) sales order ship date
        rem --- or purchase order receipt date. It's used here to determine how far
        rem --- out inventory records need to be created

        last$=last$(1,6)

        rem --- If inventory is installed and any firm is either using lotted/serialized
        rem --- inventory or LIFO/FIFO costing then additional files need to be opened.

        ls=0
        lf=0

        rem --- Check inventory parameters for each firm

        for firm=1 to firms step 2
            firm_id$=firms$(firm,2)
            find record (adm06_dev,key=firm_id$,dom=*continue) adm06a$
            find record (ivs_params_dev,key=firm_id$+"IV00",dom=*continue) ivs_params$
            if pos(ivs_params.lifofifo$="LF") lf=1
            if pos(ivs_params.lotser_flag$="LS") ls=1
        next firm

        rem --- Open lot/serial and/or LIFO/FIFO files if necessary

        files=2,begfile=1,endfile=files
        dim files$[files],options$[files],ids$[files],templates$[files],channels[files]
        if lf files$[1]="ivm-04",ids$[1]="IVM_ITEMTIER"
        if ls files$[2]="ivm-07",ids$[2]="IVM_LSMASTER"
        if ls or lf call pgmdir$+"adc_fileopen.aon",action,begfile,endfile,files$[all],options$[all],ids$[all],templates$[all],channels[all],batch,status
        if status goto std_exit
        ivm04_dev=channels[1]
        ivm07_dev=channels[2]

        rem --- Dimension string templates

        if lf dim ivm04a$:templates$[1]
        if ls dim ivm07a$:templates$[2]

        rem --- For each valid firm

        for firm=1 to firms step 2

            rem --- Is Inventory installed for this firm?

            firm_id$=firms$(firm,2)
            gosub application_used
            if notused continue

            rem --- Initializations for the current firm

            dim change[days]
            ls=0
            lf=0
            onhand=0
            committed=0
            d=num(dd$)
            m=num(mm$)
            y=num(yyyy$);rem --- d,m,y added here 8/2009 CAH;need to re-init for each firm, because m and y get re-used in future months routine
            
            rem --- Retrieve parameter record for this firm

            find record (ivs_params_dev,key=firm_id$+"IV00",dom=*continue) ivs_params$
            if pos(ivs_params.lifofifo$="LF") lf=1
            if pos(ivs_params.lotser_flag$="LS") ls=1

            rem --- Position Inventory Master (ivm-01) file

            read (ivm01_dev,key=firm_id$,dom=*next)

            rem --- Read next Inventory Master (ivm-01) record

            while moreheaders
                k$=key(ivm01_dev,end=*break)
                if pos(firm_id$=k$)<>1 break
                gosub update_meter
                read record (ivm01_dev) ivm01a$
                item$=firm_id$+ivm01a.item_id$

                rem --- Position Warehouse Detail (ivm-02) file

                read (ivm02_dev,key=item$,knum="AO_ITEM_WH",dom=*next)

                rem --- Read next Warehouse Detail (ivm-02) record
                rem --- and accumulate quantities

                while 1
                    k$=key(ivm02_dev,knum="AO_ITEM_WH",end=*break)
                    if pos(item$=k$)<>1 break
                    read record (ivm02_dev,key=k$,knum="AO_ITEM_WH") ivm02a$
                    warehouse$=firm_id$+ivm02a.warehouse_id$+ivm02a.item_id$
                    cost=ivm02a.unit_cost
                    qty_onhand=ivm02a.qty_on_hand
                    qty_committed=ivm02a.qty_commit
                    quantity=0
                    total=0

                    rem --- Accumulate LIFO/FIFO quantities and extensions if it is 
                    rem --- being used in order to calculate the average cost 

                    while lf
                        read (ivm04_dev,key=warehouse$,dom=*next)
                        while 1
                            k$=key(ivm04_dev,end=*break)
                            if pos(warehouse$=k$)<>1 break
                            read record (ivm04_dev) ivm04a$
                            quantity=quantity+ivm04a.qty_on_hand
                            total=total+(ivm04a.qty_on_hand*ivm04a.unit_cost)
                        wend
                        cost=fnavgcost(quantity,total,qty_onhand,cost)
                        break
                    wend

                    rem --- Accumulate Lot/Serial quantities and extensions if using 
                    rem --- lotted or serialized inventory in order to calculate the
                    rem --- average cost 

                    while ls
                        if ivm01a.lotser_item$<>"Y" break
                        if ivm01a.inventoried$<>"Y" break
                        read (ivm07_dev,key=warehouse$,dom=*next)
                        while 1
                            k$=key(ivm07_dev,end=*break)
                            if pos(warehouse$=k$)<>1 break
                            read record (ivm07_dev) ivm07a$
                            if ivm07a.closed_flag$<>"C"
                                quantity=quantity+ivm07a.qty_on_hand
                                total=total+(ivm07a.qty_on_hand*ivm07a.unit_cost)
                            endif
                        wend
                        cost=fnavgcost(quantity,total,qty_onhand,cost)
                        break
                    wend

                    rem --- Accumulate committed and on hand amounts

                    committed=committed+(qty_committed*cost)
                    onhand=onhand+(qty_onhand*cost)

                    rem --- Use the Inventory Transaction History (ivt-04) file
                    rem --- to accumulate changes by day for prior days in the 
                    rem --- current month

                    if d>1
                        for x=1 to d
                            transaction$=warehouse$+yyyy$+mm$+str(x:"00")
                            read (ivt04_dev,key=transaction$,dom=*next)
                            while 1
                                k$=key(ivt04_dev,end=*break)
                                if pos(transaction$=k$)<>1 break
                                read record (ivt04_dev) ivt04a$
                                if ivt04a.trans_source$<>"BB" change[x]=change[x]+((-ivt04a.trans_qty)*cost)
                            wend
                        next
                    endif

                rem --- Loop back for next warehouse detail record
                wend

            rem --- Loop back for next inventory item
            wend

            rem --- Initialize current month record

            dim a[days]
            a[0]=committed
            a[d]=onhand

            rem --- Calculate actual value by day for prior dates in the
            rem --- current month by adjusting the amount using the total
            rem --- change for that date accumulated from the Inventory
            rem --- Transaction History (ivt-04) file

            if d>1
                for x=d-1 to 1 step -1
                    a[x]=change[x+1]+a[x+1]
                next x
            endif

            rem --- Fill the remaining days of the month using the balance
            rem --- the current date

            if d<days
                for x=d+1 to days
                    a[x]=a[d]
                next x
            endif
            rem --- Write the record for the current month

            dim rec$:fattr(ade09a$)
            rec.firm_id$=firm_id$
            rec.full_year$=yyyy$
            rec.month$=mm$
            rec.commit_value=a[0]
            action$="U"
            amountvar$="inv_oh_bydt"
            gosub summary_data
            rec$=field(rec$)

            write record (ade09_dev) rec$

            rem --- Create records for future months out until the last
            rem --- month that sales order ships or a PO receipt is scheduled
            rem --- to 

            while more
                m=m+1
                if m>12 
                    y=y+1
                    m=1
                endif
                y$=str(y:"0000")
                m$=str(m:"00")
                period$=y$+m$
                if period$>last$ break
                dim rec$:fattr(ade09a$),a[days]
                a[0]=committed
                for x=1 to days
                    a[x]=onhand
                next x
                rec.firm_id$=firm_id$
                rec.full_year$=y$
                rec.month$=m$
                rec.commit_value=a[0]
                action$="U"
                amountvar$="inv_oh_bydt"
                gosub summary_data
                rec$=field(rec$)

                write record (ade09_dev) rec$
            wend

            rem --- Update inventory records with future sales orders
            rem --- FACTOR is used to either add to or subtract from
            rem --- existing inventory balance amounts

            template$=fattr(ade05a$)
            amountvar$="ord_cst_ship"
            channel=ade05_dev
            factor=-1
            gosub update_inventory

            rem --- Update inventory records with future purchase orders

            template$=fattr(ade06a$)
            amountvar$="po_amt_rec"
            channel=ade06_dev
            factor=1
            gosub update_inventory

        rem --- Next firm
        next firm

        rem --- End of phase processing for Inventory
        break
    wend

rem ---------------------------------------------------------------------
rem --- Phase 7: Sales Analysis (sales and costs)
rem ---------------------------------------------------------------------

    while sa

        rem --- Start up the progress meter

        phase$="Sales Analysis"
        channel=opt01_dev

        rem --- Initializations for Sales Analysis

        dim a[days],u[days],l[days]
        application$="ARIVOP"
        using_units=1
        using_lines=0

        rem --- For each valid firm

        for firm=1 to firms step 2

            rem --- Is Sales Analysis installed for this firm?

            firm_id$=firms$(firm,2)
            gosub application_used
            if notused continue

            rem --- Position Invoice History Header file (opt-01)

            read (opt01_dev,key=firm_id$,dom=*next)

            rem --- Read next Invoice History Header record

            while moreheaders
                k$=key(opt01_dev,end=*break)
                if pos(firm_id$=k$)<>1 break
                gosub update_meter
                read record (opt01_dev) opt01a$
                units=1

                rem --- Determine the estimated date for this sale

                when$=opt01a.invoice_date$
                if cvs(when$,2)="" continue
                year$=when$(1,4)
                month$=when$(5,2)
                d=num(when$(7,2))

                rem --- Update sales record

                dim rec$:fattr(ade07a$)
                amountvar$="sls_inv_bydt"
                unitsvar$="no_inv_bydt"
                channel=ade07_dev
                amount=opt01a.total_sales
                gosub update_record

                rem --- Update costs record

                dim rec$:fattr(ade08a$)
                amountvar$="cost_inv_dte"
                unitsvar$="no_inv_bydt"
                channel=ade08_dev
                amount=opt01a.total_cost
                if amount gosub update_record

            rem --- Loop back for next header
            wend

        rem --- Next firm
        next firm

        rem --- End of phase processing for Sales Analysis
        break
    wend

rem ---------------------------------------------------------------------
rem --- Phase 8: Shop Floor Control (work in process)
rem ---------------------------------------------------------------------

    while sf

        rem --- Start up the progress meter

        phase$="Work in Process"
        channel=sfe01_dev

        rem --- Initializations for Work in Process

        dim a[days],u[days],l[days]
        applilcation$="IVSF"
        using_units=0
        using_lines=0

        rem --- For each valid firm

        for firm=1 to firms step 2

            rem --- Is Shop Floor Control installed for this firm?

            firm_id$=firms$(firm,2)
            gosub application_used
            if notused continue

            rem --- Position Work Order Header file (sfe-01)

            wip=0
            read (sfe01_dev,key=firm_id$,dom=*next)

            rem --- Read next Work Order Header record

            while moreheaders
                k$=key(sft01_dev,end=*break)
                if pos(firm_id$=k$)<>1 break
                gosub update_meter
                read record (sft01_dev) sft01a$
                workorder$=sfe01a.firm_id$+sfe01a.wo_location$+sfe01a.wo_no$

                rem --- Open?

                if sfe01a.wo_status$<>"O" continue

                rem --- Read through detail open work order transactions and accumulate
                rem --- the work in process total for this firm

                rem --- Position all transaction files

                read (sft01_dev,key=workorder$,dom=*next)
                read (sft21_dev,key=workorder$,dom=*next)
                read (sft31_dev,key=workorder$,dom=*next)

                rem --- Read next Open Work Order Operations Transaction (sft-01) record

                while 1
                    k$=key(sft01_dev,end=*break)
                    if pos(workorder$=k$)<>1 break
                    read record (sft01_dev) sft01a$
                    wip=wip+sft01a.ext_cost
                wend

                rem --- Read next Open Work Order Material Transaction (sft-21) record

                while 1
                    k$=key(sft21_dev,end=*break)
                    if pos(workorder$=k$)<>1 break
                    read record (sft21_dev) sft21a$
                    wip=wip+sft21a.ext_cost
                wend

                rem --- Read next Open Work Order Subcontract Transaction (sft-31) record

                while 1
                    k$=key(sft31_dev,end=*break)
                    if pos(workorder$=k$)<>1 break
                    read record (sft31_dev) sft31a$
                    wip=wip+sft31a.ext_cost
                wend

            rem --- Loop back for next header
            wend

            rem --- Write WIP record for this firm

            dim rec$:fattr(ade10a$)
            year$=yyyy$
            month$=mm$
            d=0
            amountvar$="tot_wip_amt"
            channel=ade10_dev
            amount=wip
            if amount gosub update_record

        rem --- Next firm
        next firm

        rem --- End of phase processing for Shop Floor Control
        break
    wend

rem ---------------------------------------------------------------------
rem --- Phase 9: Custom executive summary processing
rem ---------------------------------------------------------------------

    while custom

        rem --- Any custom processing should be inserted here

    wend

rem ---------------------------------------------------------------------
rem --- Phase 10: Consolidation
rem ---------------------------------------------------------------------
rem escape;rem consolidation
rem --- Initializations

    firm99$="99"

rem --- Transfer channel numbers of summary files to an array for easier processing

    files=summary_files,begfile=2,endfile=files
    dim channels[files]
    channels[2]=ade02_dev
    channels[3]=ade03_dev
    channels[4]=ade04_dev
    channels[5]=ade05_dev
    channels[6]=ade06_dev
    channels[7]=ade07_dev
    channels[8]=ade08_dev
    channels[9]=ade09_dev
    channels[10]=ade10_dev

rem --- Switch/Case flags

    generation=1
    receivables=2
    payables=3
    order_sales=4
    order_costs=5
    purchases=6
    invoice_sales=7
    invoice_costs=8
    inventory=9
    wip=10
    custom=11

rem --- For each Executive Summary (ade-xx) file

    for file=begfile to endfile

        rem --- Does this file require consolidation?

        if used[file]=0 continue

        rem --- Start up the progress meter

        phase$="Consolidation ("+summary_files$[file]+")"
        channel=summary_channels[file]

        rem --- Default initializations for most applications

        begday=1
        endday=days
        using_units=1
        using_lines=0

        rem --- Perform initializations based on current file

        switch file
            case generation
            break
            case receivables
                dim firmnnrec$:fattr(ade02a$),firm99rec$:fattr(ade02a$)
                amountvar$="inv_due_bydt"
                unitsvar$="no_inv_due"
            break
            case payables
                dim firmnnrec$:fattr(ade03a$),firm99rec$:fattr(ade03a$)
                amountvar$="inv_due_bydt"
                unitsvar$="no_inv_due"
            break
            case order_sales
                dim firmnnrec$:fattr(ade04a$),firm99rec$:fattr(ade04a$)
                amountvar$="ord_amt_ship"
                unitsvar$="no_ord_ship"
                linesvar$="no_lns_ship"
                using_lines=1
            break
            case order_costs
                dim firmnnrec$:fattr(ade05a$),firm99rec$:fattr(ade05a$)
                amountvar$="ord_cst_ship"
                unitsvar$="no_ord_ship"
                linesvar$="no_lns_ship"
                using_lines=1
            break
            case purchases
                dim firmnnrec$:fattr(ade06a$),firm99rec$:fattr(ade06a$)
                amountvar$="po_amt_rec"
                unitsvar$="no_lns_rec"
            break
            case invoice_sales
                dim firmnnrec$:fattr(ade07a$),firm99rec$:fattr(ade07a$)
                amountvar$="sls_inv_bydt"
                unitsvar$="no_inv_bydt"
            break
            case invoice_costs
                dim firmnnrec$:fattr(ade08a$),firm99rec$:fattr(ade08a$)
                amountvar$="cost_inv_dte"
                unitsvar$="no_inv_bydt"
            break
            case inventory
                dim firmnnrec$:fattr(ade09a$),firm99rec$:fattr(ade09a$)
                amountvar$="inv_oh_bydt"
                using_units=0
            break
            case wip
                dim firmnnrec$:fattr(ade10a$),firm99rec$:fattr(ade10a$)
                amountvar$="tot_wip_amt"
                using_units=0
                begday=0
                endday=0
            break
            case custom
            break
            case default
            break
        swend 

        rem --- Position current file
    
        read (channel,key="",dom=*next)
    
        rem --- Read next Executive Summary record

        while more
            k$=key(channel,end=*break)
            if pos(firm99$=k$)=1 break
            read record (channel) firmnnrec$

            rem --- Record initializations

            dim firm_amounts[days],firm_units[days],firm_lines[days],cons_amounts[days],cons_units[days],cons_lines[days]

            rem --- Retrieve the consolidation record if it exists

            dim firm99rec$:fattr(firmnnrec$)
            firm99_key$=firm99$+firmnnrec.full_year$+firmnnrec.month$
            firm99rec.firm_id$=firm99$
            firm99rec.full_year$=firmnnrec.full_year$
            firm99rec.month$=firmnnrec.month$
            find record (channel,key=firm99_key$,dom=*next) firm99rec$

            rem --- Transfer numeric values to working arrays

            for x=begday to endday
                firm_amounts[x]=nfield(firmnnrec$,amountvar$+"_"+str(x:"00"))
                if using_units firm_units[x]=nfield(firmnnrec$,unitsvar$+"_"+str(x:"00"))
                if using_lines firm_lines[x]=nfield(firmnnrec$,linesvar$+"_"+str(x:"00"))
                cons_amounts[x]=nfield(firmnnrec$,amountvar$+"_"+str(x:"00"))
                if using_units cons_units[x]=nfield(firmnnrec$,unitsvar$+"_"+str(x:"00"))
                if using_lines cons_lines[x]=nfield(firmnnrec$,linesvar$+"_"+str(x:"00"))
            next x

            rem --- Add current record totals to consolidation record values

            for x=begday to endday
                cons_amounts[x]=cons_amounts[x]+firm_amounts[x]
                cons_units[x]=cons_units[x]+firm_units[x]
                cons_lines[x]=cons_lines[x]+firm_lines[x]
            next x

            rem --- Transfer consolidation arrays back to that record and update it

            for x=begday to endday
                field firm99rec$,amountvar$+"_"+str(x:"00")=cons_amounts[x]
                if using_units field firm99rec$,unitsvar$+"_"+str(x:"00")=cons_units[x]
                if using_lines field firm99rec$,linesvar$+"_"+str(x:"00")=cons_lines[x]
            next x
            firm99rec$=field(firm99rec$)

            write record (channel) firm99rec$

            rem --- Reposition file and loop back for next record

            read (channel,key=k$)
        wend

    rem --- Next file
    next file

rem ---------------------------------------------------------------------
rem --- All done
rem ---------------------------------------------------------------------

    GroupSpace!.setValue("+process_task",task_id$+"^D^")

    prompt$="Executive Summary generated as of "+fndate$(generation_date$)
    x=msgbox(prompt$,64,task_description$)
    goto std_exit

rem ---------------------------------------------------------------------
rem --- Subroutines and functions
rem ---------------------------------------------------------------------

update_record: rem --- Update the current Executive Summary record

    dim a[days],u[days],l[days]
    rec.firm_id$=firm_id$
    rec.full_year$=year$
    rec.month$=month$
    k$=firm_id$+year$+month$
    find record (channel,key=k$,dom=*next) rec$
    action$="R"
    gosub summary_data
    a[d]=a[d]+amount
    if using_units u[d]=u[d]+units
    if using_lines l[d]=l[d]+lines
    units=0
    action$="U"
    gosub summary_data

    write record (channel) rec$
    return

summary_data: rem --- Return or update Executive Summary templates/arrays

rem --- This subroutine accepts the templated summary record and work
rem --- arrays and then either returns the numeric values from the 
rem --- record in those work arrays or sets the templated fields using  
rem --- the contents of them.

    action=pos(action$="RU")

rem --- Either extract the numerics and return them or set the template
rem --- variables based on the values passed in.

    switch action
            case return_values
                dim a[days],u[days],l[days]
                for x=1 to days
                    a[x]=nfield(rec$,amountvar$+"_"+str(x:"00"))
                    if using_units u[x]=nfield(rec$,unitsvar$+"_"+str(x:"00"))
                    if using_lines l[x]=nfield(rec$,linesvar$+"_"+str(x:"00"))
                next x
                break
            case update_values
                for x=1 to days
                    field rec$,amountvar$+"_"+str(x:"00")=a[x]
                    if using_units field rec$,unitsvar$+"_"+str(x:"00")=u[x]
                    if using_lines field rec$,linesvar$+"_"+str(x:"00")=l[x]
                next x
                rec$=field(rec$)
            break
            case default
            break
    swend           
    return

application_used: rem --- Is this application in use by the current firm?

    dim info$[20]
    notused=1
    flags$=""

rem --- Valid firm?

    find record (adm06_dev,key=firm_id$,dom=*return) adm06a$
    
rem --- Is this application installed for this firm?

    for x=1 to len(application$) step 2 
        module$=application$(x,2)
        call pgmdir$+"adc_application.aon",module$,info$[all]
        flags$=flags$+info$[20]
    next x
    notused=pos("N"=flags$)
    return

installed: rem --- Check to see if an application is installed

    installed=0
    for x=1 to len(application$) step 2
        k$=stbl("+AON_APPCOMPANY")+pad(application$(x,2),3)
        adm04a.sys_install$="N"
        find record (adm04_dev,key=k$,err=*next) adm04a$
        flags$=flags$+adm04a.sys_install$
    next x
    installed=pos("N"=flags$)=0
    return

add_to_total:rem --- Add to Total Record Count

    temp_xfin$=fin(total_table,err=*return)
    total_recs=total_recs+dec(temp_xfin$(77,4))

    return

update_meter:rem --- Update Record Count and Display Meter If Applicable

    proc_recs=proc_recs+1
    if mod(proc_recs,milestone)=0 groupSpace!.setValue("+process_task",task_id$+"^U^"+str(proc_recs)+"^")

    return

update_inventory: rem --- Update current and future inventory records with 
                  rem --- adjustments based on future sales and receipts

    variable$=amountvar$
    when$=generation_date$(1,6)
    x=num(when$(5,2))-1
    k$=firm_id$+when$(1,4)+str(x:"00")
    read (channel,key=k$,dom=*next)

    rem --- Read next sales/purchase order record

    while more
        dim rec$:template$
        k$=key(channel,end=*break)
        if pos(firm_id$=k$)<>1 break
        read record (channel,key=k$) rec$
        lastkey$=k$
        yyyymm$=k$(3)
        amountvar$=variable$
        action$="R"
        gosub summary_data

        rem --- Adjust activity using the specified multiplier (factor)

        dim adjustment[days]
        begday=d+1
        total=0
        if yyyymm$>when$ begday=1
        if begday<=days
	        for x=begday to days
	            adjustment[x]=a[x]*factor
	            total=total+abs(adjustment[x])
	        next x
        endif

        rem --- Any activity?

        if total=0 continue

        rem --- Adjust inventory balances for the current month/year
        rem --- to reflect the expected activity
        

        for x1=begday to days
            amount=adjustment[x1]
            if amount=0 continue

            rem --- Adjust current and future inventory records

            needkey=1
            k$=lastkey$
            read (ade09_dev,key=k$,dom=*next); needkey=0
            while more
                dim rec$:fattr(ade09a$)
                if needkey k$=key(ade09_dev,end=*break)
                if pos(firm_id$=k$)<>1 break
                read record (ade09_dev,key=k$) rec$
                needkey=1
                amountvar$="inv_oh_bydt"
                action$="R"
                gosub summary_data
                for y=x1 to days
                    a[y]=a[y]+amount
                next y
                action$="U"
                gosub summary_data

                write record (ade09_dev,key=k$) rec$
            wend
        next x1

        rem --- Reposition file and loop back for the next record

        read (channel,key=lastkey$) 

    wend

    return

announcement: rem --- Diagnostic subroutine that prompts on phase entry/exit

    prompt$=prompt$+" "+phase$+" (Press <Enter> to continue): "
    print prompt$,
    input *,

    return
    
    open_tables:rem --- Open Tables
    
        call stbl("+DIR_SYP")+"bac_open_tables.bbj",
:       open_beg,
:       open_end,
:       open_tables$[all],
:       open_opts$[all],
:       open_chans$[all],
:       open_tpls$[all],
:       table_chans$[all],
:       open_batch,
:       open_status$
    
        if open_status$<>"" then
            msg_id$="ENTRY_OPEN_ERROR"
            dim msg_tokens$[1]
            msg_tokens$[1]=open_status$
            gosub disp_message
            rdFuncSpace!=bbjAPI().getGroupNamespace().setValue("+build_task","OFF")
            release
        endif
    
    return

disp_message:rem --- Display Message Dialog

    call        dirsyp$+"bac_message.bbj",
:       msg_id$,
:       msg_tokens$[all],
:       msg_opt$,
:       table_chans$[all]

    return

rem --- Functions

    def fndate$(q$)
        q1$=""
        q1$=date(jul(num(q$(1,4)),num(q$(5,2)),num(q$(7,2)),err=*next),err=*next)
        if q1$="" q1$=q$
        return q1$
    fnend

rem --- fnavgcost: Calculate average cost based on quantity and
rem ---         total extended amount

    def fnavgcost(q1,q2,q3,q4)
        if q1<>q3 
            q5=q3-q1
            q1=q1+q5
            q2=q2+(q5*q4)
        endif
        if q1 q4=q2/q1
        return q4
    fnend

rem #include std_error.src

std_error: rem --- Standard error handler (01Apr2006)

    err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) err_text$=pgm(tcb(5))
    call stbl("+DIR_PGM",err=std_error_exit)+"bac_error.aon",err=std_error_exit,pgm(-2),str(tcb(5)),
    :   str(err),err_text$,err_act$
    if pos("EXIT"=err_act$) goto std_error_exit
    if pos("ESCAPE"=err_act$) seterr 0;setesc 0
    if pos("RETRY"=err_act$) retry

std_error_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_error_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_error_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_error_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape

std_error_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_error.src

rem #include std_missing_params.src

std_missing_params: rem --- Standard missing parameter handler (15Apr2006)

    err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) err_text$=pgm(tcb(5))
    dir_pgm$=stbl("+DIR_PGM",err=std_missing_params_exit)
    call dir_pgm$+"adc_noparams.aon",err=std_missing_params_exit,pgm(-2),str(tcb(5):"00000"),str(err:"000"),err_text$,err_act$

std_missing_params_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_missing_params_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_missing_params_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_missing_params_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape

std_missing_params_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_missing_params.src

rem #include std_end.src

std_exit: rem --- Standard program end (01Mar2006)

    run stbl("+DIR_SYP")+"bas_process_end.bbj",err=*next

    release

rem #endinclude std_end.src

    end
