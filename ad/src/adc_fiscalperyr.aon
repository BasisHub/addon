rem --- Return Fiscal Period/Year
rem --- Program adc_fiscalperyr.aon (syc_pb)

rem --- AddonSoftware Version 17.00
rem --- Copyright BASIS International Ltd.  All Rights Reserved.
rem --------------------------------------------------------------------------------

rem --- FIRM_ID$      : Firm ID (Input)
rem --- WHEN$         : YYYYMMDD Date (Input)
rem --- PERIOD$       : Fiscal period MM (Returned - blank if incoming date was invalid)
rem --- YEAR$         : Fiscal year YYYY (Returned - blank if incoming date was invalid)
rem --- TABLE_CHANS$[]: Barista opened channels array
rem --- STATUS        : Zero=No Error/Not Zero=Error (Returned)

    seterr std_error
    setesc std_error
    
    enter firm_id$,when$,period$,year$,table_chans$[all],status

rem --- Validate WHEN$ date

    when_jul=-1
    when_jul=jul(num(when$(1,4)),num(when$(5,2)),num(when$(7,2)),err=*next)
    if when_jul<0 then
        period$=""
        year$=""
        goto done
    endif
    date$=when$
    fiscal_year$=date$(1,4)

rem --- Retrieve sysinfo data

    sysinfo_template$=stbl("+SYSINFO_TPL",err=*next)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=*next)
    milestone=num(stbl("+MILESTONE",err=*next),err=*next)
    if cvs(firm_id$,2)="" then firm_id$=sysinfo.firm_id$

rem --- Open/Lock files

    num_files=1
    dim open_tables$[1:num_files],open_opts$[1:num_files],open_chans$[1:num_files],open_tpls$[1:num_files]
    open_tables$[1]="GLS_CALENDAR",open_opts$[1]="OTA@"
    
    gosub open_tables
    
    gls_calendar_dev=num(open_chans$[1])
    dim gls_calendar$:open_tpls$[1]

get_calendar: rem --- Get calendar for the fiscal year

    find record (gls_calendar_dev,key=firm_id$+fiscal_year$,dom=*next)gls_calendar$
    if cvs(gls_calendar.firm_id$,2)="" then
        msg_id$="AD_NO_FISCAL_CAL"
        dim msg_tokens$[1]
        msg_tokens$[1]=fiscal_year$
        gosub disp_message
        status=1
        goto std_exit
    endif
    periods=num(gls_calendar.total_pers$)

rem --- Make sure we used the fiscal calendar for the correct year.

    start_date$=gls_calendar.year$+gls_calendar.cal_start_date$
    start_jul=jul(num(start_date$(1,4)),num(start_date$(5,2)),num(start_date$(7,2)))
    if when_jul<start_jul then
        fiscal_year$=str(num(fiscal_year$)-1)
        goto get_calendar
    endif

rem --- Initializations

    numbers$="01020304050607080910111213"
    numbers$=numbers$(1,periods*2)
    period$=""
    year$=""
    p=0
    y=0

rem --- Sort period ending dates and corresponding period numbers

    for x=1 to periods
        periods$=periods$+field(gls_calendar$,"per_ending_"+str(x:"00"))
    next x

    for x=2 to periods
        priper=(x-2)*4+1
        curper=(x-1)*4+1
        if periods$(curper,4)>periods$(priper,4) continue
        periods$=periods$(curper)+periods$(1,curper-1)
        w=int(curper/4)*2+1,numbers$=numbers$(w)+numbers$(1,w-1)
        break
    next x

rem --- Which period/year?

    mmdd$=date$(5)
    p=pos(mmdd$<=periods$,4)
    if p<>0
        p=num(numbers$(int(p/4)*2+1,2))
        y=num(date$(1,4))
        if p>1 if field(gls_calendar$,"per_ending_"+str(p:"00"))<gls_calendar.per_ending_01$ y=y-1
    else
        rem --- 'ENTERED' date is > than all period end dates
        p=num(numbers$(periods*2-1))+1
        y=num(date$(1,4))
        if p>periods p=1,y=y+1
    endif

    period$=str(p:"00")
    year$=str(y:"0000")

done: rem --- All done

    goto std_exit
   
open_tables:rem --- Open Tables

    call stbl("+DIR_SYP")+"bac_open_tables.bbj",
:       open_beg,
:       open_end,
:       open_tables$[all],
:       open_opts$[all],
:       open_chans$[all],
:       open_tpls$[all],
:       table_chans$[all],
:       open_batch,
:       open_status$

    if open_status$<>"" then
        msg_id$="ENTRY_OPEN_ERROR"
        dim msg_tokens$[1]
        msg_tokens$[1]=open_status$
        gosub disp_message
        rdFuncSpace!=bbjAPI().getGroupNamespace().setValue("+build_task","OFF")
        release
    endif
    return

disp_message: rem --- Display Message Dialog

    call stbl("+DIR_SYP")+"bac_message.bbj",msg_id$,msg_tokens$[all],msg_opt$,table_chans$[all]

    return

rem #include std_error.src

std_error: rem --- Standard error handler (11Oct2017)

    if tcb(19)>0
        rem --- Escape handler
        if and(chr(tcb(19)),$08$)=$08$
            release
        else
            setesc std_error
            return
        endif
    endif

    if err=0   
        rem --- Get tcb(12) and tcb(10) to send into bac_error
        lock_byte=tcb(10)
        lock_chan=tcb(12)  
    endif

    rd_err_text$="",err_num=err
    if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
    if err_num=252 then
        E!=BBjAPI().getLastBBjException()
        rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
        if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
    endif
    call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$,lock_byte,lock_chan
    if pos("ESCAPE"=rd_err_act$) seterr 0; setesc 0
    if pos("RETRY"=rd_err_act$) retry
    if pgm(-1)<>pgm(-2) status=999; exit 
    release

rem #endinclude std_error.src

rem #include std_missing_params.src

std_missing_params: rem --- Standard missing parameter handler (15Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    pgmdir$=stbl("+DIR_PGM",err=std_missing_params_exit)
    call pgmdir$+"adc_noparams.aon",err=std_missing_params_exit,pgm(-2),str(tcb(5)),
:                                   str(err),rd_err_text$,rd_err_act$
std_missing_params_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_missing_params_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_missing_params_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_missing_params_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_missing_params_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_missing_params.src

rem #include std_exit.src

std_exit: rem --- Standard called program exit (01Mar2006)

    exit
rem #endinclude std_exit.src

    end
