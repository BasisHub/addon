rem --- Calendar Maintenance (Display, Modify Calendar, ChUI)
rem --- Program poc_cg v8.0.0 20Dec2007 (poc_cg)
rem --- Created by c:\codeport_bbj\adx_codeport.bbj v1.1.5 (12/20/2007 04:41:54)

rem --- AddonSoftware Version 8.0.0 - 01Jan2007
rem --- Copyright BASIS International Ltd.  All Rights Reserved.
rem --- All Rights Reserved

    seterr std_error
    setesc std_error
    enter file_dev,a0$,status

rem --- Retrieve the program path

    pgmdir$=stbl("+dir_pgm",err=*next)

rem --- Retrieve sysinfo data

    sysinfo_template$=stbl("+sysinfo_tpl",err=*next)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+sysinfo",err=*next)
    milestone=num(stbl("+milestone",err=*next),err=*next)
    firm_id$=sysinfo.firm_id$

rem --- Open/Lock files

    files=3,begfile=1,endfile=files
    dim files$[files],options$[files],ids$[files],templates$[files],channels[files]
    files$[1]="aps_params",ids$[1]="APS_PARAMS"
    files$[2]="filea",ids$[2]=""
    files$[3]="ivs_params",ids$[3]="IVS_PARAMS"
    call pgmdir$+"adc_fileopen.aon",action,begfile,endfile,files$[all],options$[all],
:                                   ids$[all],templates$[all],channels[all],batch,status
    if status goto std_exit
    aps01a_dev=channels[1]
    filea_dev=channels[2]
    ivs01a_dev=channels[3]

rem --- Dimension string templates

    dim aps01a$:templates$[1],filea$:templates$[2],ivs01a$:templates$[3]

rem --- Retrieve parameter records

    aps01a_key$=firm_id$+"AP00"
    find record (aps01a_dev,key=aps01a_key$,err=std_missing_params) aps01a$
    ivs01a_key$=firm_id$+"IV00"
    find record (ivs01a_dev,key=ivs01a_key$,err=std_missing_params) ivs01a$

rem --- Parameters

    dim t$:stbl("+TASK_TMPL")
    t$=stbl("+TASK")
    firm_id$=t.f0$(16,2)

rem --- Init Data

    count=1
    cnt=1
    more=1
    dim a1$(31),l[12]
    month=num(t.f0$(20,2))
    year=fnyy_year(t.f0$(18,2))
    days$="Sunday   Monday   Tuesday  WednesdayThursday Friday   Saturday "
    codes$="           Work Day  Closed    Holiday  "
    l[1]=31
    l[2]=28,l[3]=31,l[4]=30,l[5]=31,l[6]=30
    l[7]=31
    l[8]=31,l[9]=30,l[10]=31,l[11]=30,l[12]=31
    rarrow=32
    rarrow=num(stbl("+RARROW",err=*next),err=*next)
    larrow=31
    larrow=num(stbl("+LARROW",err=*next),err=*next)
    pgdn=38
    pgdn=num(stbl("+PGDN",err=*next),err=*next)
    darrow=34
    darrow=num(stbl("+DARROW",err=*next),err=*next)
    pgup=37
    pgup=num(stbl("+PGUP",err=*next),err=*next)

rem --- Create main window

    width=78
    height=21
    call pgmdir$+"syc_wa.bbx",0,(width),(height),1,2,"",win_name$

rem --- Fill in calendar block

    for i=10 to 65 step 11
        call pgmdir$+"syc_wc.bbx",1,1,0,height-2,i,0,0
    next i
    call pgmdir$+"syc_wc.bbx",1,0,width-2,0,0,1,0
    for i=4 to 16 step 3
        call pgmdir$+"syc_wc.bbx",1,0,width-2,0,0,i,0
    next i
    print @(22,height-4),'cl',@(22,height-3),'cl',

rem --- Month/Year?

    while more

        year$=a0$(3,2)
        year=fnyy_year(year$),month$=a0$(5,2),month=num(month$)

    rem --- Set window title

        title$=date(jul(1900+year,month,1):"%Ms %Y")
        print @(23,17),title$,"   Arrows=Change Day  PgUp/PgDn=Change Month",@(34,18),"<Space>=Toggle Status  <F4>=End",

    rem --- Days

        col=0
        row=0
        for i=1 to 7
            print @(col,row),days$(i*9-8,9),
            col=col+11
        next i

    rem --- Determine starting day of the week

        dim days[42],row[42],col[42]
        first=0
        d=0,date=0
        call pgmdir$+"adc_dayweek.aon",year$+month$+"01","",first
        first=first+1
        l[2]=28,yy=fnyy_year(year$),mm=num(month$)
        if first>7 then let first=1
        if mod(yy,4)=0 then let l[2]=29
        for i=first to 42
            date=date+1
            if date<=l[mm] then let d=d+1,days[i]=d
        next i

    rem --- Display dates on calendar

        col=0
        row=2
        for i=1 to 42
            if days[i] then print @(col,row),days[i],
            col=col+11
            if col>=77 then let col=0,row=row+3
        next i

    rem --- Display data

        col=0
        row=3,date=1,first_col=0,first_row=0
        for i=1 to 42
            if days[i]<>0 then 

                if first_row=0 then let first_row=row,first_col=col
                x$=codes$((pos(pom01a.day_status_01$=" WCH")-1)*10+1,10)
                row[date]=row
                col[date]=col
                print @(col,row),x$,
                date=date+1

            endif
        
            col=col+11
            if col>76 then let col=0,row=row+3
        next i

    rem --- Initialize for modification

        v0=1
        days=1,col=first_col,row=first_row,l_col=col,l_row=row

    rem --- Process user input

        while more

            print @(l_col,l_row)," ",@(l_col+9)," ",@(col,row),"[",@(col+9),"]",
            v0$="Sa"
            v1$="a^",v2$="",v3$="",v4$="",v1=col+4,v2=row-1,l_col=col,l_row=row
            gosub std_input
            print @(v1,v2)," ",
            if v3=4 then goto done
            if v3=rarrow then goto right_arrow
            if v3=larrow then goto left_arrow
            if v3=darrow then goto down_arrow
            if v3=2 then goto up_arrow
            if v3=pgup then break
            if v3=pgdn then goto pgdn_one_month

        rem --- Toggle status

            if pos(v$=" WCH")=0 then continue

            while more

                if v$<>" " then let a1$(days,1)=v$; break
                if a1$(days,1)="W" then let a1$(days,1)="C"; break
                if a1$(days,1)="C" then let a1$(days,1)="H"; break
                if a1$(days,1)="H" or a1$(days,1)=" " then let a1$(days,1)="W"
                a1$(days,1)="W"

            wend
        
            x$=codes$((pos(a1$(days,1)=" WCH")-1)*10+1,10)
            print @(col,row),x$,
            continue

            while more

                right_arrow: rem --- Right arrow

                    days=days+1
                    if days>l[mm] then let days=1
                    break

                left_arrow: rem --- Left arrow

                    days=days-1
                    if days<1 then let days=l[mm]
                    break

                while more    

                    down_arrow: rem --- Down arrow

                        days=days+7
                        if days<=l[mm] then break
                        while days>0
                              days=days-7
                        wend
                        
                wend

                while more 

                    up_arrow: rem --- Up arrow

                        days=days-7
                        if days>0 then break
                        while days<=l[mm]
                              days=days+7
                        wend
                        
                wend

                break

            wend

            col=col[days]
            row=row[days]

        wend

    pgup_one_month: rem --- PgUp one month

        a0=l[mm]
        if cvs(a1$,2)<>"" then write record (file_dev,key=a0$) filea$
        k$=a0$
        month=num(k$(5,2))-1
        yr=fnyy_year(k$(3,2))
        if !(month<1 and yr<1) then 
            if month<1 then let month=12,k$(3,2)=fnyear_yy21$(yr-1)
            k$(5,2)=str(month:"00")
            find record (file_dev,key=k$,dom=label1) filea$
        endif
        count=0

    label1:

        if count=1

            a0$(1)=k$
            a1$(1)=""

        endif

        print 'cf',
        continue

    pgdn_one_month: rem --- PgDn one month

        a0=l[mm]
        if cvs(a1$,2)<>"" then write record (file_dev,key=a0$) filea$
        k$=a0$
        month=num(k$(5,2))+1
        yr=fnyy_year(k$(3,2))
        if month>12 then let month=1,k$(3,2)=fnyear_yy21$(yr+1)
        k$(5,2)=str(month:"00")
        find record (file_dev,key=k$,dom=label2) filea$
        cnt=0

    label2:

        if cnt=1

            a0$(1)=k$
            a1$(1)=""

        endif

        print 'cf',

    wend

done: rem --- End

    a0=l[mm]
    if cvs(a1$,2)<>"" then write record (file_dev,key=a0$) filea$
    goto std_exit

rem #include std_functions.src
rem --- Standard AddonSoftware functions (01Mar2006)
rem #endinclude std_functions.src

rem --- #include "./aon/lib/std_input.src

std_input: rem --- standard input routine (29-jan-2003)

    if restart and vaction$="s" then let vaction$="sp",restart=0
    if vaction$="g" then let compare_control=num(str(grid_id)+str(grid_row:"000")+str(grid_col:"000")) else let compare_control=control_id
    if compare_control=old_control_id then let validate=0 else let old_control_id=compare_control
    dim vdata$[10],vdata[10],vinfo$[20],vinfo[20]
    vdata$[0]=v0$
    vdata$[1]=v1$,vdata$[2]=v2$,vdata$[3]=v3$,vdata$[4]=v4$
    vdata[0]=v0
    vdata[1]=v1,vdata[2]=v2,vdata[3]=v3,vdata[4]=v
    vinfo$[0]=pgm(-2)
    vinfo$[4]=event$,vinfo[2]=control_id,vinfo[3]=i0
    vinfo[4]=i0_nonkey1
    vinfo[5]=i0_done,vinfo[6]=my_context
    vinfo[7]=validate
    vinfo[8]=statusbar_context,vinfo[9]=parent_context
    vinfo[10]=tab_control_id
    vinfo[11]=tab_index,vinfo[12]=done_context
    vinfo[14]=grid_col
    vinfo[15]=grid_row
    vinfo$[11]=vtoken1$
    vinfo$[12]=vtoken2$,vinfo$[13]=vtoken3$
    vinfo$[14]=vtoken4$
    vinfo$[15]=vtoken5$,vinfo$[16]=vtoken6$
    vinfo$[17]=vtoken7$
    vinfo$[18]=vtoken8$,vinfo$[19]=vtoken9$

rem --- call standard input routine

    call pgmdir$+"syc_ig.bbx",vaction$,vdata$[all],vdata[all],vinfo$[all],vinfo[all],vmenu$[all],vmenu[all],vtool$[all],vtool[all],vstatus
    if vstatus=127 then goto std_input_escape
    if vstatus=999 then goto std_input_error
    goto std_input_exit

std_input_escape: rem --- escape during input

    call pgmdir$+"syc_es.bbx",err=std_input_error,pgm(-2),tcb(8),e$,e2,v3
    if v3<>127 then goto std_input
    print @(0,e2),'cl','cursor'("ON"),e$,'lf'

rem --- error during input
std_input_error:
    escape
    goto std_input

rem --- assign local variables and return
std_input_exit:
    let v$=vinfo$[1],event$=vinfo$[4],v=vinfo[0],v3=vinfo[1]
    let next_control=vinfo[2],i0=vinfo[3],next_context=vinfo[6]
    let validate=vinfo[7],grid_col=vinfo[14],grid_row=vinfo[15]
    let wants_to_edit_cell=vinfo[16],next_tab_index=vinfo[18]
    if wants_to_edit_cell then dim vnotice$:vinfo$[3]; let vnotice$=vinfo$[2]
    return

rem --- #end include
rem #include std_error.src

std_error: rem --- Standard error handler (01Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    call stbl("+DIR_SYP")+"bac_error.bbj",err=std_error_exit,pgm(-2),str(tcb(5):"00000"),
:                                str(err:"000"),rd_err_text$,rd_err_act$
    if pos("EXIT"=rd_err_act$) goto std_error_exit
    if pos("ESCAPE"=rd_err_act$) seterr 0;setesc 0
    if pos("RETRY"=rd_err_act$) retry
std_error_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_error_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_error_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_error_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_error_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_error.src
rem #include std_missing_params.src

std_missing_params: rem --- Standard missing parameter handler (15Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    pgmdir$=stbl("+DIR_PGM",err=std_missing_params_exit)
    call pgmdir$+"adc_noparams.aon",err=std_missing_params_exit,pgm(-2),str(tcb(5):"00000"),
:                                   str(err:"000"),rd_err_text$,rd_err_act$
std_missing_params_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_missing_params_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_missing_params_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_missing_params_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_missing_params_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_missing_params.src

rem #include std_exit.src

std_exit: rem --- Standard called program exit (01Mar2006)

    exit
rem #endinclude std_exit.src

    end
