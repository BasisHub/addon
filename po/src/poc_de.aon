rem --- Lot/Serial Number Receipt Entry
rem --- Program poc_de v8.0.0 13Dec2007 (poc_de)
rem --- Created by c:\codeport_bbj\adx_codeport.bbj v1.1.5 (12/13/2007 12:00:08)

rem --- AddonSoftware Version 8.0.0 - 01Jan2007
rem --- Copyright (c) 1981-2007 AddonSoftware
rem --- All Rights Reserved

    setesc std_error
    seterr std_error
    enter w0$,w3$,w[all],o[all],l0,ucost

rem --- Retrieve the program path

    pgmdir$=stbl("+dir_pgm",err=*next)

rem --- Retrieve sysinfo data

    sysinfo_template$=stbl("+sysinfo_tpl",err=*next)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+sysinfo",err=*next)
    milestone=num(stbl("+milestone",err=*next),err=*next)
    firm_id$=sysinfo.firm_id$

rem --- Open/Lock files

    files=4,begfile=1,endfile=files
    dim files$[files],options$[files],ids$[files],templates$[files],channels[files]
    files$[1]="aps-01a",ids$[1]=""
    files$[2]="ivm-07",ids$[2]="IVM_LSMASTER"
    files$[3]="ivs_params",ids$[3]="IVS_PARAMS"
    files$[4]="poe-24",ids$[4]="POE_RECLSDET"
    call pgmdir$+"adc_fileopen.aon",action,begfile,endfile,files$[all],options$[all],
:                                   ids$[all],templates$[all],channels[all],batch,status
    if status goto std_exit
    aps01a_dev=channels[1]
    ivm07_dev=channels[2]
    ivs01a_dev=channels[3]
    poe24_dev=channels[4]

rem --- Dimension string templates

    dim aps01a$:templates$[1],ivm07a$:templates$[2],ivs01a$:templates$[3],
:       poe24a$:templates$[4]

rem --- Retrieve parameter records

    aps01a_key$=firm_id$+"AP00"
    find record (aps01a_dev,key=aps01a_key$,err=std_missing_params) aps01a$
    ivs01a_key$=firm_id$+"IV00"
    find record (ivs01a_dev,key=ivs01a_key$,err=std_missing_params) ivs01a$

rem --- Open/Lock Files

    files=4
    dim files$[files],options$[files],channels[files]
    files$[1]="sys-01"
    files$[2]="poe-24",files$[3]="ivm-07",files$[4]="poe-24"
    options$[1]="P"
    options$[2]="P",options$[3]="P"
    call pgmdir$+"adc_fileopen.aon",1,1,files,files$[all],options$[all],channels[all],batch,status
    if status then goto std_exit
    sys01_dev=channels[1]
    poe24_dev=channels[2],ivm07_dev=channels[3],poe24_dev2=channels[4]

rem --- Determine interface

    call pgmdir$+"syc_dg.bbx",sysgui_dev,event$,event_len,sysfin$,sysfin,ui$,status
    if status then goto std_exit

rem --- Parameters

    dim i[2],t$:stbl("+TASK_TMPL")
    t$=stbl("+TASK")
    firm_id$=t.f0$(16,2),n2$="PO"
    find record (sys01_dev,key=firm_id$+"IV00",dom=std_missing_params) ivs01a$
    i[1]=num(ivs01a.precision$)
    i[2]=num(ivs01a.ls_no_len$)
    bbj=fnglobal("+BBJ",0)
    call pgmdir$+"adc_sizemask.aon",m2$,m2,9,12
    call pgmdir$+"adc_sizemask.aon",m3$,m3,9,12

rem --- Initialize Data

    precision i[1]
    dim ls_no$(20)
    l1=l0-1
    l2=l1+2,l8=20,q_col=max(30,o[3]),c_col=max(q_col+1+m2,o[4]),review=0
rem    t0$(1)=w0$(1,25)
    poe24a.firm_id$=wo$(1,2)
    poe24a.vendor_id$=wo$(3,6)
    poe24a.receiver_no$=wo$(9,7)
    poe24a.po_no$=wo$(16,7)
    poe24a.po_line_no$=wo$(23,3)
    lotser$=ivs01a.lotser_flag$,cost=w[1]/w[0],tot_qnty=0,qnty=w[7]*w[0]
    turn_off_grid_hilite=57
    goto_col=47,goto_row=48,draw_cell=54,grid_info_block=20,get_visible_rows=43,get_top_row=46,get_sel_row=45,set_multi_cells=87,set_rows=67,set_editable=108; rem grid sendmsg functions
    grid_id=200
    max_row=999,max_col=3; rem must match resource
    dim col2print[max_col]
    col2print[0]=4
    col2print[1]=9,col2print[2]=q_col,col2print[3]=c_col
    dim key2row[max_row],row2key$[max_row]
    for i=0 to max_row; let key2row[i]=-1; next i
    seq_inc=1
    call pgmdir$+"syc_rg.bbx::save",globalvars$,ignore_status
    more=1

rem --- Display GUI resource

    if ui$<>"W" 
        print @(0,l8+1),'ce',
        while l>l2
              print @(0,l1),'ld',
              l=l-1
        wend
    else
        prior_context=sysfin.current_context
        dim resparams$[20],resparams[20]
        resparams$[0]=pgm(-2)
        resparams$[6]="Enter Lots/Serial Numbers"
        call pgmdir$+"syc_ra.bbx","O",resparams$[all],resparams[all],vmenu$[all],vmenu[all],vtool$[all],vtool[all],status
        if status then goto std_exit

    rem --- Setup Grid

        dim grid$:tmpl(sysgui_dev,ind=1)
        grid$=sendmsg(sysgui_dev,grid_id,grid_info_block,0,"")
        void$=sendmsg(sysgui_dev,grid_id,turn_off_grid_hilite,0,"")
        visible_rows=dec($00$+sendmsg(sysgui_dev,grid_id,get_visible_rows,0,""))
        if bbj then let void$=sendmsg(sysgui_dev,grid_id,set_editable,1,"")
        
    endif

rem ---  list_existing

    while more
    
        gosub list_all
        tot_qnty=0
        read (poe24_dev,key=w0$(1,25),dom=*next)

        while more

                k$=key(poe24_dev,end=*break)
                if pos(w0$(1,25)=k$)<>1 then break
                read record (poe24_dev) poe24a$
                tot_qnty=tot_qnty+poe24a.unit_cost

        wend

    rem --- Totals match?

        if tot_qnty=0 and qnty=0 then goto std_exit
        if tot_qnty=qnty then goto start_done
        if lotser$<>"S" or tot_qnty then goto overflow
        v2=l
        gosub gen_serial_nums
        if !success then break

    wend

    overflow: rem --- Overflow

    while more

        if ui$<>"W" 
            if l>l8 then print @(0,l8+1),'ce',@(0,l2),'ld',; let l=l-1
        endif
        if v3=4 then break

        rem --- Next Key

        k$=key(poe24_dev,end=seq_no)

        while more

            if pos(w0$(1,25)=k$)=1
                read record (poe24_dev) poe24a$
            else

            seq_no: rem --- Seq

                if (qnty>=0 and tot_qnty<qnty) or (qnty<0 and tot_qnty>qnty) then if ui$<>"W" or next_grid_row=0 then let t0=num(poe24a_key.sequence_no$)+1 else let t0=min(num(row2key$[next_grid_row-1])+seq_inc,max_row) else let t0=0

            seq_no_entry:

                v0$="Z"
                v1$="KCER",v2$=str(t0:"000"),v3$="",v0=3,v1=4,v2=l,i0=0,control_id=grid_id,grid_col=i0,grid_row=key2row[num(v2$)],vaction$="g"
                v4$="Enter A Lot/Serial Detail Sequence Number (<Enter>=Next)"
                if grid_row=-1 then let grid_row=next_grid_row
                rem gosub std_input
                if (ui$="W" and grid_row=next_grid_row) or (ui$<>"W" and v3=4) then let row=grid_row,junk=fnclear_col(grid_col)
                if ui$="W" and grid_row<>next_grid_row junk=fnprint_col(grid_col); rem restore orignal value of key if not a new line.  new value will be printed only if this is a new key.
                if wants_to_edit_cell and vnotice.row<>next_grid_row goto goto_grid_cell; rem if this is a new record and the user click on a field in the new row, ignore it.
                on v3 goto label1,seq_no_entry,seq_no_entry,seq_no_entry,start_done,start_done,start_done,seq_no_entry,seq_no_entry

            label1:

                if v<0 or num(v$)=0 then goto seq_no_entry
                poe24a_key.sequence_nbr$=v$
                find record (poe24_dev,key=poe24a_key.firm_id$+poe24a_key.vendor_nbr$+poe24a_key.reciever_nbr$+poe24a_key.po_number$+poe24a_key.po_line_nbr$+poe24a_key.sequence_nbr$,dom=new_record) poe24a$

            endif

            display_record: rem --- Display an existing record

            seq_qnty=t[0]
            gosub display_fields
            break

            new_record: rem --- Setup

            while more

                if tot_qnty=qnty then goto start_done
                dim ls_no$(20)
                if lotser$="S" then let poe24a.qty_received=sgn(qnty) else let poe24a.qty_received=qnty-tot_qnty
                seq_qnty=0
                poe24a.unit_cost=ucost
                key2row[num(poe24a.sequence_no$)]=next_grid_row
                row2key$[next_grid_row]=poe24a.sequence_no$
                junk=fnprint_col(grid_col)
                break

                lotser: rem --- Enter Lot/Serial Number

                while more

                    v0$="S"
                    v1$="CE",v2$=poe24a.lotser_no$,v3$="",v4$="Enter a Lot/Serial Number",v0=i[2],v1=9,v2=l,i0=1
                    control_id=grid_id
                    grid_col=i0,grid_row=key2row[num(poe24a_key.sequence_no$)],vaction$="g"; rem escape, junk = fntbfkey( "+TB_FIND_ID", 3 )

                    on v3 goto label2,lotser,flow_control,lotser,flow_control,label2,flow_control

                label2:

                    if cvs(v$,2)="" then continue
                    ls_no$(1)=v$

                    rem --- Want record for returns but not receipts

                    find record (ivm07_dev,key=firm_id$+w3$+ls_no$,dom=label3) ivm07a$
                    if poe24a.qty_received<0 then break

                label3:
                    if poe24a.qty_received>=0 then break
                
                lotser_warn: rem --- Warn Existing/Non-existing Lot/Serial Number

                    dim messages$[1]
                    messages$[0]="This Lot/Serial Number is already on file."
                    if poe24a.qty_received<0 then let messages$[0]="This Lot/Serial Number is NOT on file."
                    if lotser$="L" and poe24a.qty_received>=0 then let messages$[1]="  <Enter>=Continue   <F2>=Change" else let messages$[1]="         <Enter>=Continue"
                    call pgmdir$+"adc_stdmessage.aon",2,messages$[all],1,22,-1,v$,v3
                    if lotser$<>"S" then if lotser$<>"L" or v3<>2 then if lotser$<>"L" or poe24a.qty_received>=0 then break

                wend

                lotser_good: rem --- Good Lot/Serial Number

                poe24a.lotser_no$=ls_no$
                gosub display_fields
                break

                while more

                rcv_qty: rem --- Received Quantity

                    if lotser$="S" then break
                    v0$="N"
                    v1$="C",v2$=str(t[0]),v3$=m2$,v4$="Enter Quantity Received",v0=m2,v1=q_col,v2=l
                    control_id=grid_id
                    grid_col=i0,grid_row=key2row[num(poe24a_key.sequence_nbr$)],vaction$="g"
                    on v3 goto label4,rcv_qty,flow_control,rcv_qty,flow_control,label4,flow_control

                label4:

                    if qnty<0 or (v>0 and v<=qnty) then if qnty>0 or (v<0 and v>=qnty) then poe24a.qty_received=v;break

                wend

                break; rem --- goto flow_control

                while more

                unit_cost: rem --- Unit Cost

                    v0$="N"
                    v1$="C",v2$=str(poe24a.unit_cost),v3$=m3$,v4$="Enter Cost Per Unit-Of-Sale",v0=m3,v1=c_col,v2=l
                    control_id=grid_id
                    grid_col=i0,grid_row=key2row[num(poe24a_key.sequence_no$)],vaction$="g"
                    on v3 goto label5,unit_cost,flow_control,unit_cost,flow_control,label5,flow_control

                label5:

                    if v>=0 
                        poe24a.unit_cost=v
                        ucost=poe24a.unit_cost
                        break
                    endif

                wend
                
                break; rem --- goto flow_control

            wend

            flow_control: rem --- Flow Control

            if debug then print (debug_dev)"Starting flow control with i0=",str(i0),", v3=",str(v3)
            grid_data$=fnglobal$(grid_stbl$,"")
            if wants_to_edit_cell and vnotice.row%<>grid_row then let wants_to_edit_cell=0,needs_to_edit_cell=1; break
            switch v3
            case 0
            case 1
            case 3; let i0=i0+1; break
            case 2; let i0=max(0,i0-1); break; rem allow backup into seq
            case 4
            case 5; break
            case 6
            if grid_row=next_grid_row then let row=grid_row;rem  gosub clear_grid_row
            new_detail=0
            exitto start_done
            case default; exitto done_v3
            swend
            if debug then print (debug_dev)"Going to field",i0

            next_field:
            on i0 goto seq_no,lotser,rcv_qty,unit_cost,is_line_correct
            break

        wend

        is_line_correct: rem --- Correct?

        if validate=0 then let validate=1,v3=0,old_control_id=0,i0=i0_nonkey1; goto next_field
        validate=0
        if ui$<>"W"

        label6:

            v0$=""
            v2$="",v3$="",v0=1,v1=78,v2=l,k9$=poe24a_key.firm_id$+poe24a_key.vendor_nbr$+poe24a_key.reciever_nbr$+poe24a_key.po_number$+poe24a_key.po_line_nbr$+poe24a_key.sequence_nbr$,v4$="<Enter>=OK, <F2>=Change, <D>=Delete",i0=i0_done

            on v3 goto label7,label6,flow_control,label6,label7

            label7:
            if v$<>"" and v$<>"D" then continue
            if v$="D" then goto delete_line

        endif

        update_line: rem --- Write

        tot_qnty=tot_qnty-seq_qnty+poe24a.qty_received
        poe24a_key$=poe24a_key.firm_id$+poe24a_key.vendor_no$+poe24a_key.reciever_no$+poe24a_key.po_no$+poe24a_key.po_line_no$+poe24a_key.sequence_no$
        write record (poe24_dev,key=poe24a_key$) poe24a$
        l=l+1
        if ui$<>"W" then print @(0,21),'ce',
        if new_detail and ui$="W" then gosub insert_new_key
        if needs_to_edit_cell then goto goto_grid_cell
        if review<>0 
            k$=key(poe24_dev,end=done)
            if pos(w0$(1,25)=k$)<>1 then break
        else
             if tot_qnty=qnty then break
        endif

        continue

        delete_line: rem --- Delete

        if ui$="W" 

            gosub delete_a_key; if dont_delete then goto delete_record
            if grid_row=-1 or delete_row<>next_grid_row 
                tot_qnty=tot_qnty-seq_qnty
                remove (poe24_dev,key=poe24a_key.firm_id$+poe24a_key.vendor_nbr$+poe24a_key.reciever_nbr$+poe24a_key.po_number$+poe24a_key.po_line_nbr$+poe24a_key.sequence_nbr$,dom=*next)
            endif

        else
            tot_qnty=tot_qnty-seq_qnty
            remove (poe24_dev,key=poe24a_key.firm_id$+poe24a_key.vendor_nbr$+poe24a_key.reciever_nbr$+poe24a_key.po_number$+poe24a_key.po_line_nbr$+poe24a_key.sequence_nbr$,dom=*next)

        endif
        if ui$<>"W" then print @(0,l),'cl',@(0,21),'ce',
        goto overflow

        break

    wend
    
    rem --- Start ITAIC

start_done:

    i0=i0_done

done: rem --- Options

    if ui$<>"W" then print @(0,l),'ce',
    review=0
    if tot_qnty<>qnty then gosub not_enough; if v$="N" then goto overflow
    if ui$<>"W" then let v4$="Is The Lot/Serial Information Correct (Y/N/Review/List/Delete)?" else let v4$="Is The Lot/Serial Information Correct?"
    v0$="S"
    v1$="C",v2$="Y",v3$="",v0=6,v1=0,v2=22,control_id=grid_id,grid_col=i0-i0_done+1,grid_row=-1,vaction$="g"

    if wants_to_edit_cell then goto goto_grid_cell

done_v3:

    on v3 goto done_test,done,done,done,recalc_cost,recalc_cost,recalc_cost,delete_line,insert_record

done_test:

    if v$="R" or v$="REVIEW"

        if v$="L" or v$="LIST"

            if v$="DELETE"

                if v$="" then let v$="Y"

                action=pos(v$="YN")
                switch(action)

                    case 1
                        goto recalc_cost
                        break
                    case 2
                        goto overflow
                        break
                    case default
                        goto done
                        break
                swend

            insert_record:

                goto seq_no

            recalc_cost: rem --- Re-Calculate Cost Per Unit-Of-Sale

                c=0
                q=0
                read (poe24_dev,key=w0$(1,25),dom=*next)

                while more

                    k$=key(poe24_dev,end=*break)
                    if pos(w0$(1,25)=k$)<>1 then break
                    read record (poe24_dev) poe24a$
                    q=q+poe24a.qty_received
                    c=c+poe24a.qty_received*poe24a.unit_cost

                wend

                if q=0 then let ucost=cost else let ucost=c/q
                goto back_to_caller

            endif

        delete_record: rem --- Delete All Assignments Here

            if ui$="W" 
                call pgmdir$+"adc_yesno.aon",0,"Delete this record and all detail lines",0,vv$,v3
                if v3 or vv$="NO" then goto start_done
                if vv$<>"YES" then goto delete_record
            else
                read (poe24_dev,key=w0$(1,25),dom=*next)
            endif

            while more

                k$=key(poe24_dev,end=*break)
                if pos(w0$(1,25)=k$)<>1 then break
                remove (poe24_dev,key=k$)

            wend

            ucost=cost
            void$=stbl("!CLEAR",grid_stbl$,err=*next)

        back_to_caller: rem --- Run Overlay

            if ui$<>"W" then print @(72,l),'cl',@(0,l2),'ce',
            goto std_exit

        endif

    do_list: rem --- List

        gosub list_all
        goto start_done

    endif

review: rem --- Review

    read (poe24_dev,key=w0$(1,25),dom=*next)
    rem gosub clear_screen
    review=1
    goto overflow

display_fields: rem --- Display Fields

rem --- escape needed? if ui$<>"W" and t0$<=k9$ then gosub clear_screen

    void=fnprint_col(0)
    void=fnprint_col(1),void=fnprint_col(2),void=fnprint_col(3)
    k9$=poe24a_key.firm_id$+poe24a.vendor_no$+poe24a.reciever_no$+poe24a.po_no$+poe24a.po_line_no$+poe24a.sequence_no$
    return

list_all: rem --- List

    if ui$="W" then print (sysgui_dev)'title'(2001,w3$(3,20)),
    rem gosub clear_screen
    nothing_found=1
    next_grid_row=0
    read (poe24_dev,key=w0$(1,25),dom=*next)

    while more

        k$=key(poe24_dev,end=label8)
        if pos(w0$(1,25)=k$)=1

            key2row[num(k$(26,3))]=next_grid_row
            row2key$[next_grid_row]=k$(26,3)
            read record (poe24_dev) poe24a$
            if ui$<>"W" and l>l8 

                v0$="S"
                v1$="CE",v2$="",v3$="",v4$="Press <Enter> To Continue",v0=1,v1=fnv(v4$),v2=22
                if v3=4 then break
                rem gosub clear_screen

            else
                gosub display_fields
                l=l+1
                nothing_found=0
                next_grid_row=min(next_grid_row+1,max_row)
                continue
            endif

        endif
        break

    wend

label8:

    return

rem --- Clear Screen

rem    for ii=l2 to l8
rem        print @(0,ii),'cl',
rem    next ii
rem    l=l2
rem    return

not_enough: rem --- Assigned Number Warning

    v0$="Only "+str(tot_qnty)+" Items Were Assigned Lot/Serial Numbers."
    v1$="The Total Quantity Received Is "+str(qnty)+"."
    v2$="<Enter>=Review"
    max_elems=2,max_len=max(len(v0$),len(v1$))+2
    dim message$[max_elems](max_len)
    message$[0](fncenter(v0$,max_len))=v0$
    message$[1](fncenter(v1$,max_len))=v1$
    message$[2](fncenter(v2$,max_len-6))=v2$
    call pgmdir$+"adc_stdmessage.aon",2,message$[all],max_elems,22,-1,v$,v3
    v$="N"
    if v3=4 then let v$=""
    return

gen_serial_nums: rem --- Generate List Of Serial Numbers

    success=0
    if qnty>0

        dim serial$[1]
        call pgmdir$+"ivc_sn.bbx",sys01_dev,v2,qnty,serial$[all],sn_status
        if sn_status or num(serial$[0])=0 then break
        for ii=1 to num(serial$[0])

            poe24a.lotser_no$=serial$[ii]
            find (ivm07_dev,key=firm_id$+w3$+poe24a.lotser_no$,dom=label9)
            continue

        label9: rem --- Write poe-24 Record For New Serial Number

            t0=num(poe24a_key.sequence_no$)+1
            tot_qnty=tot_qnty+1
            if t0>999 or tot_qnty>qnty then break
            poe24a.sequence_no$=str(t0:"000")
            poe24a.qty_received=1,poe24a.unit_cost=ucost
            poe24a_key$=poe24a.firm_id$+poe24a.vendor_nbr$+poe24a.reciever_nbr$+poe24a.po_number$+poe24a.po_line_nbr$+poe24a.sequence_nbr$
            write record (poe24_dev,key=poe24a_key$) poe24a$

        next ii
        success=1

    endif

    return

delete_a_key: rem --- Delete a key from key2row, row2key, grid_data$

    dont_delete=1
    delete_row=dec($00$+sendmsg(sysgui_dev,grid_id,get_sel_row,0,""))

    while more

        if row2key$[delete_row]="" then break
        call pgmdir$+"adc_yesno.aon",0,"Delete detail line "+row2key$[delete_row],0,v$,v3
        if v3 or v$<>"YES" then break
        dont_delete=0
        poe24a.sequence_no$=row2key$[delete_row],row2key$[delete_row]="",key2row[num(poe24a.sequence_no$)]=-1,grid_row=-1,grid_data$=fnglobal$(grid_stbl$,"")
        if delete_row=next_grid_row then let row=delete_row;break

        for ix=delete_row to next_grid_row

            row2key$[ix]=row2key$[ix+1]
            key2row[num(row2key$[ix])]=ix
            for iy=0 to max_col
                grid_data$=fnhash_ins$(grid_data$,str(iy)+":"+str(ix),fnhash_ext$(grid_data$,str(iy)+":"+str(ix+1)))
            next iy

        next ix
        next_grid_row=next_grid_row-1
        junk$=stbl(grid_stbl$,grid_data$)
        junk$=sendmsg(sysgui_dev,grid_id,set_rows,min(next_grid_row+20,max_row),$$)
        gosub redraw_grid

    wend

delete_a_key_done:

    return

insert_new_key: rem --- Insert new key into key2row, row2key arrays

rem --- and update grid_data$

    new_detail=0
    hold_key$=poe24a.sequence_no$,ix=next_grid_row,grid_data$=fnglobal$(grid_stbl$,"")

    while more

        if ix and row2key$[ix-1]<=hold_key$ 

    rem --- Insert here (we're at the top or row above is less)

            row2key$[ix]=hold_key$
            key2row[num(hold_key$)]=ix
            for iy=0 to max_col
                grid_data$=fnhash_ins$(grid_data$,str(iy)+":"+str(ix),fnset_cell$(iy))
            next iy
            break

        else

            row2key$[ix]=row2key$[ix-1]
            key2row[num(row2key$[ix])]=ix
            for iy=0 to max_col
                grid_data$=fnhash_ins$(grid_data$,str(iy)+":"+str(ix),fnhash_ext$(grid_data$,str(iy)+":"+str(ix-1)))
            next iy
            ix=ix-1
        endif

    wend

    next_grid_row=min(next_grid_row+1,max_row)
    grid_row=-1,void$=stbl(grid_stbl$,grid_data$)
    gosub redraw_grid
    void$=sendmsg(sysgui_dev,grid_id,set_rows,min(next_grid_row+20,max_row),$$)
    return

rem --- Clear a grid row

rem --- IN: row
rem    for col=0 to max_col
rem        void=fnclear_col(col)
rem    next col
rem    return

rem --- Goto grid cell

    goto_grid_cell:

    if debug then print (debug_dev)"In goto_grid_cell: (",vnotice.col%,vnotice.row%,")"
    let wants_to_edit_cell=0,needs_to_edit_cell=0,i0=vnotice.col%,hold_k$=row2key$[vnotice.row%],new_detail=0

    if hold_k$="" 
        let poe24a.sequence_no$=hold_key$,i0=0,new_detail=1
    endif

    while more

        if hold_k$=poe24a.sequence_no$ then break
        if debug then print (debug_dev)"Going to grid cell",i0,", row",vnotice.row%,", key = ",hold_k$
        find record (poe24_dev2,key=poe24a.firm_id$+poe24a.vendor_no$+poe24a.reciever_no$+poe24a.po_no$+poe24a.po_line_no$+hold_k$,dom=ggc_new_key) poe24a$
        if poe24a.qty_received<0 then find record (ivm07_dev,key=firm_id$+w3$+poe24a.lotser_no$,dom=ggc_new_key) ivm07a$
        let seq_qnty=poe24a.qty_received
        gosub display_fields
        break

    ggc_new_key:

        let poe24a.sequence_no$=hold_key$,i0=0,new_detail=1

    wend

ggc_done:

    goto next_field

redraw_grid: rem " --- Redraw grid

    let top_row=dec($00$+sendmsg(sysgui_dev,grid_id,get_top_row,0,""))
    let bot_row=min(max_row,top_row+visible_rows-1)

    if top_row<=bot_row

        for row=top_row to bot_row
            for col=0 to max_col
                let grid.col%=col,grid.row%=row
                let grid.buf$=fnhash_ext$(grid_data$,str(col)+":"+str(row))
                if fncol2type$(col)="Y" then if grid.buf$="Y" or grid.buf$="YES" then let grid.style%=4,grid.buf$="" else if grid.buf$="N" or grid.buf$="NO" then let grid.style%=8,grid.buf$=""
                let void$=sendmsg(sysgui_dev,grid_id,draw_cell,0,grid$,my_context)
            next col
        next row

    endif

    return


rem #include std_functions.src
rem --- Standard AddonSoftware functions (01Mar2006)

rem --- Miscellaneous functions

    def fncenter(q$,q)=int((q-len(q$))/2)

rem --- fnglobal: Return numeric value of passed stbl variable

    def fnglobal(q$,q1)
        q1$=stbl(q$,err=*next),q1=num(q1$,err=*next)
        return q1
    fnend

rem --- fnglobal$: Return string value of passed STBL variable

    def fnglobal$(q$,q1$)
        q1$=stbl(q$,err=*next)
        return q1$
    fnend

rem #endinclude std_functions.src

rem #include std_error.src

std_error: rem --- Standard error handler (01Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    call stbl("+DIR_SYP")+"bac_error.bbj",err=std_error_exit,pgm(-2),str(tcb(5):"00000"),
:                                str(err:"000"),rd_err_text$,rd_err_act$
    if pos("EXIT"=rd_err_act$) goto std_error_exit
    if pos("ESCAPE"=rd_err_act$) seterr 0;setesc 0
    if pos("RETRY"=rd_err_act$) retry
std_error_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_error_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_error_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_error_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_error_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_error.src
rem #include std_missing_params.src

std_missing_params: rem --- Standard missing parameter handler (15Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    pgmdir$=stbl("+DIR_PGM",err=std_missing_params_exit)
    call pgmdir$+"adc_noparams.aon",err=std_missing_params_exit,pgm(-2),str(tcb(5):"00000"),
:                                   str(err:"000"),rd_err_text$,rd_err_act$
std_missing_params_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_missing_params_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_missing_params_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_missing_params_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_missing_params_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_missing_params.src

rem #include std_exit.src

std_exit: rem --- Standard called program exit (01Mar2006)

    exit
rem #endinclude std_exit.src

    end
