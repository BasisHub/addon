rem --- Calendar Maintenance
rem --- Program poc_cb v8.0.0 18Dec2007 (poc_cb)
rem --- Created by c:\codeport_bbj\adx_codeport.bbj v1.1.5 (12/18/2007 04:44:56)

rem --- AddonSoftware Version 8.0.0 - 01Jan2007
rem --- Copyright BASIS International Ltd.  All Rights Reserved.
rem --- All Rights Reserved

    seterr std_error
    setesc std_error
    enter filename$,status

rem --- Retrieve the program path

    pgmdir$=stbl("+dir_pgm",err=*next)

rem --- Retrieve sysinfo data

    sysinfo_template$=stbl("+sysinfo_tpl",err=*next)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+sysinfo",err=*next)
    milestone=num(stbl("+milestone",err=*next),err=*next)
    firm_id$=sysinfo.firm_id$

rem --- Open/Lock files

    files=3,begfile=1,endfile=files
    dim files$[files],options$[files],ids$[files],templates$[files],channels[files]
    files$[1]="aps-01a",ids$[1]=""
    files$[2]="filea",ids$[2]=""
    files$[3]="ivs_params",ids$[3]="IVS_PARAMS"
    call pgmdir$+"adc_fileopen.aon",action,begfile,endfile,files$[all],options$[all],
:                                   ids$[all],templates$[all],channels[all],batch,status
    if status goto std_exit
    aps01a_dev=channels[1]
    filea_dev=channels[2]
    ivs01a_dev=channels[3]

rem --- Dimension string templates

    dim aps01a$:templates$[1],filea$:templates$[2],ivs01a$:templates$[3]

rem --- Retrieve parameter records

    aps01a_key$=firm_id$+"AP00"
    find record (aps01a_dev,key=aps01a_key$,err=std_missing_params) aps01a$
    ivs01a_key$=firm_id$+"IV00"
    find record (ivs01a_dev,key=ivs01a_key$,err=std_missing_params) ivs01a$

rem --- Open/Lock Files

    files=1
    dim files$[files],options$[files],channels[files]
    files$[1]=filename$
    call pgmdir$+"adc_fileopen.aon",1,1,files,files$[all],options$[all],channels[all],batch,status
    if status then goto std_exit
    file_dev=channels[1]; rem or if called by mpm_da, mpm-02

rem --- Determine interface

    call pgmdir$+"syc_dg.bbx",sysgui_dev,event$,event_len,sysfin$,sysfin,ui$,status
    if status then goto std_exit

rem --- Parameters

    dim t$:stbl("+TASK_TMPL")
    t$=stbl("+TASK")
    firm_id$=t.f0$(16,2)

rem --- Init Data

    more=1
    dim a0$(6),a1$(31),l[12]
    month=num(t.f0$(20,2))
    year=fnyy_year(t.f0$(18,2))
    days$="Sunday   Monday   Tuesday  WednesdayThursday Friday   Saturday "
    codes$="           Work Day  Closed    Holiday  "
    l[1]=31
    l[2]=28,l[3]=31,l[4]=30,l[5]=31,l[6]=30
    l[7]=31
    l[8]=31,l[9]=30,l[10]=31,l[11]=30,l[12]=31
    rarrow=32
    rarrow=num(stbl("+RARROW",err=*next),err=*next)


    larrow=31
    larrow=num(stbl("+LARROW",err=*next),err=*next)

    pgdn=38
    pgdn=num(stbl("+PGDN",err=*next),err=*next)

    darrow=34
    darrow=num(stbl("+DARROW",err=*next),err=*next)

    pgup=37
    pgup=num(stbl("+PGUP",err=*next),err=*next)

rem --- Display Resource

    dim resparams$[20],resparams[20]
    resparams$[0]=pgm(-2)
    call pgmdir$+"syc_ra.bbx","",resparams$[all],resparams[all],vmenu$[all],vmenu[all],vtool$[all],vtool[all],status
    if status then goto std_exit
    gosub check_gaps


rem --- Get First Day Scheduled

    while more

        call pgmdir$+"poc_ce.bbx",file_dev,firm_id$,begdate$,enddate$,status
        if begdate$<>"" then let v1$=fndate$(begdate$) else let begdate$="None"
        if enddate$<>"" then let v2$=fndate$(enddate$) else let enddate$="None"
        call pgmdir$+"syc_rs.bbx","",my_context,2100,v1$,0,"",ignore_status
        call pgmdir$+"syc_rs.bbx","",my_context,2101,v2$,0,"",ignore_status
        call pgmdir$+"syc_rs.bbx","",my_context,3000,"",month,"#0",ignore_status
        call pgmdir$+"syc_rs.bbx","",my_context,3001,fnyear_yy$(year),0,"",ignore_status
        break

        month_to_change: rem --- Month To Change

        while more

            v4$="Enter the month to change"
            v0$="N"
            v1$="KEC",v2$=str(month),v3$="0#",v0=2,v1=40,v2=5,control_id=3000
            on v3 goto label1,month_to_change,month_to_change,month_to_change,ret_record,label1,ret_record

        label1:

            if !(v<1 or v>12) break

        wend

        month=v
        call pgmdir$+"syc_rs.bbx","",my_context,control_id,"",v,"#0",ignore_status
        break

    year_to_change: rem --- Year To Change

        v4$="Enter the year to change"
        v0$="D"
        v1$="KECY",v2$=fnyear_yy21$(year),v3$="",v0=2,v1=40,v2=6,control_id=3001
        on v3 goto label2,year_to_change,month_to_change,year_to_change,ret_record,label2,ret_record

    label2:

        year=fnyy_year(v$)
        call pgmdir$+"syc_rs.bbx","",my_context,control_id,fnyear_yy$(year),0,"",ignore_status

    ret_record: rem --- Retrieve record

        year$=fnyear_yy21$(year)
        month$=str(month:"00"),filea.firm_id$=firm_id$,filea.year$=year$,filea.month$=month$
        find record (file_dev,key=filea.firm_id$+filea.year$+filea.month$,dom=new_record) filea$

    new_record: rem --- New record?

        call pgmdir$+"adc_yesno.aon",1,"No calendar exists for "+month$+"/"+fnyy$(year$)+".  Create one",2,v$,v3
        on v3 goto label3,new_record,new_record,new_record,std_exit,label3,std_exit

    label3:

        on pos(v$="YN") goto new_record,init_new_record,month_to_change

    init_new_record: rem --- Initialize new record

        goto end_input

    wend

flow_control: rem --- Flow Control

    switch v3
    case 0
    case 1
    case 3; let i0=i0+1; break
    case 2
    if i0<i0_nonkey1 then let i0=max(0,i0-1) else let i0=max(i0_nonkey1,i0-1)
    break
    rem case 4; exitto start_done
    case default; exitto done_v3
    swend

next_field:

    on i0 goto month_to_change,year_to_change,done

start_done: 
    
    let i0=i0_done

done: rem --- Correct?

    if validate

        v0$="S"
        v1$="KC",v2$="Y",v3$="",v4$="ITAC=Y",v0=6,v1=0,v2=22,control_id=i0-i0_done+1
        rem gosub std_input

    done_v3:

        on v3 goto done_test,done,done,done,cancel,validate_input,cancel,done

    done_test:

        on pos(v$="YN") goto flow_control,validate_input,do_nonkey1

    validate_input:

        validate=1
        old_control_id=0

    do_nonkey1:

        v3=0
        i0=i0_nonkey1
        goto next_field

    cancel:

        goto std_exit

    else

        let validate=0

    fi

end_input: rem --- Run Overlay

    if ui$="W" then call pgmdir$+"poc_ch.bbx",file_dev,filea.firm_id$+filea.year$+filea.month$,status else call pgmdir$+"poc_cg.bbx",file_dev,filea.firm_id$+filea.year$+filea.month$,status
    goto std_exit

check_gaps: rem --- Display Unscheduled Gaps in Calendar

    gap$=""
    read (file_dev,key=firm_id$,dom=*next)

rem --- Process First Month

    k$=key(file_dev,end=display_gaps)
    if pos(firm_id$=k$)<>1 then goto display_gaps
    read record (file_dev) filea$
    last_month$=filea.year$+filea.month$+str(a0:"00")
    filea_1$=filea$(8,31)
rem    x0=pos(" "<>a1$)
    x0=pos(" "<>filea_1$)

    while more

        x1=pos(" "=filea_1$(x0,a0+1-x0))
        if x1=0 then break
        gap$=gap$+k$(3,4)+str(x0+x1-1:"00")
        x2=pos(" "<>a1$(x0+x1-1,a0+1-(x0+x1)))
        if x2=0 then break
        gap$=gap$+k$(3,4)+str(x0+x1+x2-3:"00")
        x0=x0+x1+x2-2

    wend

    while more

        k$=key(file_dev,end=prep_display_gaps)
        if pos(firm_id$=k$)<>1 then break
        x$=""
        call pgmdir$+"adc_daydates.aon",last_month$,x$,1
        if len(x$)<>6 then break
        if x$(1,4)<>k$(3,4) then 
            if mod(len(gap$),12)=0 then let gap$=gap$+x$
        endif

        read record (file_dev) filea$
        last_month$=filea.year$+filea.month$+str(a0:"00")
        if mod(len(gap$),12)<=0 then 
            if a1$(1,1)<>" " then x0=1; goto label4
            gap$=gap$+k$(3,4)+"01"+k$(3,4)+str(pos(" "<>a1$)-1:"00")
            x0=pos(" "<>a1$)
            goto label4
        endif

        if a1$(1,1)<>" " then 
            x$=""
            call pgmdir$+"adc_daydates.aon",k$(3,4)+"01",x$,-1
            if len(x$)<>6 then break
            gap$=gap$+x$
            x0=1
            goto label4
        else
            gap$=gap$+filea.year$+filea.month$+str(pos(" "<>a1$)-1:"00")
            x0=pos(" "<>a1$)
        fi

    label4:

        while more

            x1=pos(" "=a1$(x0,a0+1-x0))
            if x1=0 then break
            gap$=gap$+k$(3,4)+str(x0+x1-1:"00")
            x2=pos(" "<>a1$(x0+x1-1,a0+1-(x0+x1)))
            if x2=0 then break
            gap$=gap$+k$(3,4)+str(x0+x1+x2-3:"00")
            x0=x0+x1+x2-2

        wend

    wend

prep_display_gaps: rem --- Now Prepare To Display Gaps

    if mod(len(gap$),12)<>0 then let gap$=gap$(1,len(gap$)-6)
    if len(gap$)=0 then return
    if ui$<>"W" then 
        print @(10,11),"The following gaps in scheduled days have been detected:",
        col=3
        row=11
    else
        call pgmdir$+"syc_rw.bbx","NP",-1,-1,460,255,"The following gaps in scheduled days have been detected",pgm(-2),$00080000$,$$,win_context$,ignore_status
        print (sysgui_dev)'listbox'(8000,10,10,440,180,"",$$),
        print (sysgui_dev)'button'(1,300,200,60,25,"OK",$$)
        print (sysgui_dev)'button'(2,370,200,60,25,"Cancel",$$)
    fi

display_gaps: rem --- Display Gaps

    flag=0
    while more

        if len(gap$)=0 then gosub lbl_continue;flag=1;break
        if ui$<>"W"
            row=row+1
            if row>21 then let col=col+20,row=12
            if col>=80
                gosub lbl_continue
                if v3=4 then flag=1;break
                print @(0,row),'ce',@(col,row),fndate$(gap$(1,6))," Through ",fndate$(gap$(7,6)),
            endif
        else
            print (sysgui_dev)'listadd'(8000,-1,fndate$(gap$(1,6))+" through "+fndate$(gap$(7,6))),
            gap$=gap$(13)
        endif

    wend

    if flag return

end_of_gaps:

    gosub lbl_continue

    return

    rem --- Continue?

lbl_continue:

    let v4$="Press <Enter> To Continue:"
    let v0$="S",v1$="C",v2$="",v3$="",v0=1,v1=fnv(v4$),v2=22,control_id=1
    let col=3,row=11
    call pgmdir$+"syc_dc.bbx",num(win_context$),my_context,ignore_status
    return

rem #include std_functions.src
rem --- Standard AddonSoftware functions (01Mar2006)

rem --- Date/time handling functions

    def fndate$(q$)
        q1$=""
        q1$=date(jul(num(q$(1,4)),num(q$(5,2)),num(q$(7,2)),err=*next),err=*next)
        if q1$="" q1$=q$
        return q1$
    fnend
    
    def fnyy$(q$)=q$(3,2)


rem #endinclude std_functions.src

rem #include std_error.src

std_error: rem --- Standard error handler (01Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    call stbl("+DIR_SYP")+"bac_error.bbj",err=std_error_exit,pgm(-2),str(tcb(5):"00000"),
:                                str(err:"000"),rd_err_text$,rd_err_act$
    if pos("EXIT"=rd_err_act$) goto std_error_exit
    if pos("ESCAPE"=rd_err_act$) seterr 0;setesc 0
    if pos("RETRY"=rd_err_act$) retry
std_error_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_error_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_error_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_error_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_error_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_error.src
rem #include std_missing_params.src

std_missing_params: rem --- Standard missing parameter handler (15Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    pgmdir$=stbl("+DIR_PGM",err=std_missing_params_exit)
    call pgmdir$+"adc_noparams.aon",err=std_missing_params_exit,pgm(-2),str(tcb(5):"00000"),
:                                   str(err:"000"),rd_err_text$,rd_err_act$
std_missing_params_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_missing_params_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_missing_params_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_missing_params_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_missing_params_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_missing_params.src

rem #include std_exit.src

std_exit: rem --- Standard called program exit (01Mar2006)

    exit
rem #endinclude std_exit.src

    end
