rem adx - CodePort Program Conversion Utility (Conversion Overlay)
rem Program adx_codeportconv.bbj v8.0.0 12Oct2007
rem 
rem  +-----------------------------------------+
rem  | AddonSoftware Version 8.0.0 - 01Feb2006 |
rem  |  Copyright (c) 1981-2006 AddonSoftware  |
rem  |          All Rights Reserved            |
rem  +-----------------------------------------+
rem 

rem --- If converting version 7, we should be coming into this program with a bbxfile$ (tokenized bbx pgm) of source_dir$+xxx_xx.bbx.
rem --- This program will call the _label utility on bbxfile$, resulting in a file in outputdir$ with a .lbl extension (still tokanized)

rem --- If converting v6, we've already called adc_oldport, which calls the _label utility, then calls bbjlst, creating lstfile$ of outputdir$+xxx_xx.lst,
rem --- It massages that text to look like a v7 program.  Finally, it re-compiles using bbjcpl, saving back into the xxx_xx.lbl file. 

rem --- Given the v6 or 7 tokenized .lbl file, this program uses bbjlst, making a new listfile w/ line numbers removed, saving to outputdir$ as xxx_xx.lst (lstfile$).

rem --- From there, this program opens/reads xxx_xx.lst and loads it into a lines$[] array for further text manipulation
rem --- Control then continues on into adx_codeportlbls and adx_codeporterrs programs, 
rem ---     where lines$[] array is finally saved as source in outputdir$ as newfile$ (xxx_xx plus the extension specified in the option entry form).
rem --- Before moving on to next program or at the end, lblfile$ and lstfile$ are removed from outputdir$, leaving only the new source file.

rem --- Initializations
    dim iolists$[99],resets$[99]
    let iolists=0,resets=0
    let when$=DATE(0:"%Dz%Ms%Y"),app$=cvs(basename$(1,2),8)
    let resetverbs$="resetclearbeginstart"

rem --- Always make sure ads-01 gets opened and application
rem --- parameter record is read.
    let parm$=app$,iolists=iolists+1
    if app$="op" then let parm$="ar"
    if app$="po" then let parm$="ap"
    let rec$=parm$+"s01a: (Generated by CodePort)"
    if app$="sy" then let rec$="sys01t: (Generated by CodePort)"
    let iolists$[iolists]=rec$
    if pos(app$="bmopposf",2)=0 then goto convert_program
    rem --- Additional required parameters
    if app$="bm" then let parm$="iv"
    if app$="op" then let parm$="iv"
    if app$="po" then let parm$="iv"
    if app$="sf" then let parm$="iv"
    let rec$=parm$+"s01a: (Generated by CodePort)"
    let iolists=iolists+1
    let iolists$[iolists]=rec$

rem --- Convert program
convert_program: 

    rem --- Convert line number references to labels for v7 files (already done in adc_oldport.bbj if converting v6)
    if source_version=7 then gosub convert_linenumbers
    rem --- Convert program from executable to source listing, removing line numbers
    gosub bbjlst
    rem --- Load source listing
    gosub load_sourcecode
    rem --- Convert to lower case
    gosub lower_case
    rem --- Replace standard sections with temporary #include's
    gosub std_includes
    rem --- Replace standard date handing functions
    gosub replace_functions
    rem --- Formatting comments
    gosub format_comments
    rem --- Update copyright
    gosub update_copyright
    rem --- Remove any statements beginning with a reset verb
    gosub remove_resets
    rem --- Move labels
    gosub move_labels
    rem --- Process simple LET statements
    gosub let_statements
    rem --- Indent code as necessary
    gosub indent_code
    rem --- Store IOLIST's
    gosub store_iolists
    rem --- Check code for channel references not using an IOLIST
    gosub channel_references
    let channel_lines=numlines
    rem --- Parse IOLIST's and build variable table
    gosub parse_iolists
    rem --- Replace IOLIST references with record/template processing"
    gosub iolist_references
    rem --- Remove IOLIST statements
    gosub REMOVE_IOLISTS
    rem --- Combine labels
    gosub combine_labels
    rem --- Remove THEN clause from the IF statements
    gosub remove_thens
    rem --- Indent all code per new v8.x standard
    gosub final_indenting
    rem --- Search and replace code as indicated in replacements.ini
    gosub replace_code
    rem --- Replace #include's with actual code
    gosub replace_includes
    rem --- Insert program initialization code
    gosub program_initializations
    rem --- Remove any extra blank lines
    gosub remove_blanklines

rem --- Run the next overlay
next_overlay: 
    run "adx_codeportlbls.bbj",err=the_end

rem --- Convert line number references to labels for v7 files (bbxfile$ is tokenized .bbx file, lblfile$ is still tokenized - but now in outputdir$)
convert_linenumbers: 
    let rd_meter_data$="Calling _label utility for v7 executable..."+basename$
    gosub disp_meter
    let lblfile$=outputdir$+basename$+lbl$   
    call "_label",bbxfile$,lblfile$,status$,1 
return


rem --- Convert v6 or v7 program from executable to source listing (saved with .lst extension as lstfile$)
bbjlst: 
    let rd_meter_data$="Creating source listing from v7 program executable..."+basename$
    gosub disp_meter 
    lstfile$=outputdir$+basename$+lst$
    erase lstfile$,err=*next    
    command$="bbjlst -w1024 -l -xlst "+$22$+lblfile$+$22$
    let x=scall(command$)
return


rem --- Load source listing
rem --- executed twice; first time right after doing the bbjlst, 2nd time after converting to lower case
rem --- continuation lines should be found first time thru, so shouldn't find any after doing lower case routine
load_sourcecode:
    dim lines$[9999]
    let rd_meter_data$="Loading source listing..."+lstfile$
    gosub disp_meter
    let txt_dev=unt,numlines=0
    open (txt_dev)lstfile$

    rem --- Top of source code read loop
    next_txt: 
        read (txt_dev,end=load_sourcecode_exit)rec$
        if rec$="" then goto next_txt
        if rec$(1,1)<>":" then goto store_line        
        rec$=rec$(2)
        let lines$[numlines]=lines$[numlines]+rec$
    goto next_txt

    rem --- Store the line
    store_line: 
        let numlines=numlines+1
        let lines$[numlines]=rec$
        goto next_txt

    load_sourcecode_exit: 
        let original=numlines
      
return

rem --- Convert to lower case
lower_case: 
    let rd_meter_data$="Performing case conversion..."+lstfile$
    gosub disp_meter   
    close (txt_dev)
    erase lstfile$
    string lstfile$
    open (txt_dev)lstfile$
    for x=1 to numlines
        rec$=lines$[x]
        for i=1 to len(rec$)
            if mod(pos($22$=rec$(1,i),1,0),2)=0 rec$(i,1)=cvs(rec$(i,1),8)
        next i
        write (txt_dev)rec$
    next x
    close (txt_dev) 
    gosub load_sourcecode
return 

rem --- Replace standard sections with temporary #include's
std_includes: 
    let rd_meter_data$="Replacing standard program sections with #include's..."
    let action=2,options$[1]=basename$
    gosub modify_code
return 

rem --- Remove any existing date functions
replace_functions: 
    let rd_meter_data$="Replacing standard date handling functions..."
    let action=3
    gosub modify_code
return

rem --- Formatting comments
format_comments: 
    let rd_meter_data$="Formatting comment lines..."
    let action=4,options$[1]=basename$
    gosub modify_code
return 

rem --- Update copyright
update_copyright: 
    let action=2
    let rd_meter_data$="Updating program copyright..."
    gosub initializations
return 

rem --- Move labels to separate line (except rem's)
move_labels: 
    let rd_meter_data$="Moving labels..."
    let action=6
    gosub modify_code
return 

rem --- Process simple LET statements
    let_statements: 
    let rd_meter_data$="Processing simple LET statements..."
    let action=7
    gosub modify_code
return 

rem --- Indent code where necessary
indent_code: 
    let rd_meter_data$="Indenting code as necessary..."
    let action=8
    gosub modify_code
return 

rem --- Storing IOLIST's
store_iolists: 
    let rd_meter_data$="Storing IOLIST's..."
    gosub disp_meter
    for x=1 to numlines
        let rec$=cvs(lines$[x],8),stored=0
        if pos(": iolist"=rec$)=0 or pos("sys01"=rec$) then continue
        for z=1 to iolists
            if rec$(1,6)=iolists$[z](1,6) then let stored=1
        next z
        if stored=0 then let iolists=iolists+1,iolists$[iolists]=rec$
    next x
return

rem --- Check code for channel references not using an IOLIST
channel_references: 
    let rd_meter_data$="Checking for channel references..."
    gosub disp_meter
    for x=1 to numlines
        let rec$=cvs(lines$[x],1+2+8)
        dev_check: 
        let z=pos("rem "=rec$),p=pos("_dev"=rec$)
        if p=0 then continue
        if z then if p>z then continue
        let b=p-5,l=min(p+3,len(rec$))
        if b<1 then continue
        let x$=rec$(b,l-b+1),x$=x$(1,5),rec$=rec$(l+1),b=0
        if pos(x$(1,2)="aparbmglivmpoppoprsasfsy",2)=0 then let x$=iolists$[1](1,5)
        for z=1 to iolists
            if x$=iolists$[z](1,5) then let b=z
        next z
        if b=0 then let iolists=iolists+1,iolists$[iolists]=fnerror$(x$+"a: Channel reference",x)
        if cvs(rec$,2)<>"" then goto dev_check
    next x
return 

rem --- Parse IOLIST's (Not implemented/Reserved for future use)
parse_iolists: 
return 

rem --- Insert initialization code
program_initializations: 
    let action=0
    if basename$(3,1)="c" then let action=1
    let rd_meter_data$="Inserting program initialization code..."
    gosub initializations
return 

rem --- Replace IOLIST's with record/template processing
iolist_references: 
    let rd_meter_data$="Replacing iolist's with record/template processing..."
    let action=9
    gosub modify_code
return 

rem --- Remove IOLIST lines
remove_iolists: 
    let rd_meter_data$="Removing IOLIST statements..."
    let action=10
    gosub modify_code
return 

rem --- Combine labels with previous comment where possible
combine_labels: 
    let rd_meter_data$="Building combined paragraphs..."
    let action=11
    gosub modify_code
return 

rem --- Remove the then clause from if statements
remove_thens: 
    let rd_meter_data$="Removing the THEN clause from IF statements..."
    let action=12
    gosub modify_code
return 

rem --- Perform final formatting
final_indenting: 
    let rd_meter_data$="Performing final formatting..."
    let action=13
    gosub modify_code
return 

rem --- Remove any extra blank lines
remove_blanklines: 
    let rd_meter_data$="Removing extraneous blank lines..."
    let action=14
    gosub modify_code
return 

rem --- Search and replace code as indicated in replacements.ini
replace_code: 
    let rd_meter_data$="Replacing code fragments as required..."
    gosub disp_meter
    for x=1 to numlines
        let rec$=lines$[x]
        for y=1 to replacements
            replacement_test: 
            let p=pos(oldcode$[y]=rec$),l=len(oldcode$[y])
            if p=0 then goto next_replacement
            let rec$=rec$(1,p-1)+newcode$[y]+rec$(p+l)
            goto replacement_test
            next_replacement: 
        next y
        let lines$[x]=rec$
    next x
    rem --- Search and replace completed
return 

rem --- Replace #include's with actual code
replace_includes: 
    if replace_includes=0 then goto replace_includes_skipped
    let rd_meter_data$="Replacing #include's with actual code...",lowest=1
    gosub disp_meter
    replace_pass: 
    let includes=0
    for x=1 to numlines
        let rec$=lines$[x],p=pos("#include"=rec$),inc_dev=0
        if p<>1 then goto next_include_x
        let include$=cvs(rec$(p+9),1+2),inc_dev=unt,includes=1
        if lowest=1 then let lowest=x
        open (inc_dev)libdir$+include$
        let line=x
        gosub delete_line
        next_include_line: 
            read (inc_dev,end=next_include)rec$
            let rec$=cvs(rec$,2)
            if rec$="" then if pos("rem"=lines$[x-1])=0 then goto next_include_line
            if pos("rem"=rec$)=1 then if pos("rem"=lines$[x-1]) then goto next_include_line
            let lines$[x]=rec$,x=x+1,line=x
            gosub insert_line
            goto next_include_line
        next_include: 
            close (inc_dev,err=next_include_x)
        next_include_x: 
    next x
    if includes then goto replace_pass
    for x=lowest to numlines
        let rec$=cvs(lines$[x],2)
        if pos("rem"=rec$)<>1 then goto next_insert_rem
        if cvs(lines$[x-1],2)="" then goto next_insert_check
        if pos("rem"=cvs(lines$[x-1],2)) then goto next_insert_rem
        let line=x,x=x+1
        gosub insert_line
        goto next_insert_rem
        next_insert_check: 
        if pos("rem"=cvs(lines$[x-2],2))=0 then goto next_insert_rem
        let line=x-1
        gosub delete_line
        next_insert_rem: 
    next x
    replace_includes_skipped: 
return 

rem --- Remove any reset statements (RESET, CLEAR, BEGIN and START)
remove_resets: 
    let rd_meter_data$="Searching for reset verbs..."
    gosub disp_meter
    for line=1 to numlines
        let rec$=cvs(lines$[line],1+2)
        let l=len(rec$)
        if len(rec$)<5 then continue
        let x$=rec$(1,5)
        let p=pos(x$=resetverbs$,5)
        if p=0 then continue
        let l=min(12,l)
        let x$=cvs(resetverbs$(p,5),4)+" statement removed ["+rec$(1,l)+"]"
        let resets=resets+1
        let resets$[resets]=fnerror$(x$,line)
        gosub delete_line
        let line=max(1,line-1)
    next line

return 

rem --- Call adc_codeportconv.bbx to perform the requested action
modify_code: 
    gosub disp_meter
    call "adc_codeportconv.bbj",action,lines$[all],options$[all],numlines,custom_lines! 
return 

rem --- Call adc_codeportint.bbx to perform initializations
initializations: 
    gosub disp_meter
    let options$[1]=basename$,options$[2]=newfile$,options$[3]=when$
    let options$[4]=utility$,options$[5]=version$,options$[6]=arguments$
    call "adc_codeportinit.bbj",action,options$[all],lines$[all],numlines,iolists$[all],iolists
return 

rem --- Display range of LINES$ (debugging tool)
listlines: 
    for x=b to e
        print "(",x:"0000","): ",lines$[x]
    next x
    escape 
return 

disp_meter:rem --- Display Progress Meter

    call stbl("+DIR_SYP")+"bam_prog_bar.bbj",rdSysGUI!,rdForm!,rdMeterWin!,rd_meter_title$,rd_meter_total_recs,rd_meter_proc_recs,rd_meter_data$,rd_meter_action$
    print (log_dev)fndatestamp$(0),rd_meter_data$,cr$
    return

rem --- Insert a blank line at LINE
insert_line: 
    let numlines=numlines+1
    for z=numlines to line+1 step -1
        let lines$[z]=lines$[z-1]
    next z
    let lines$[line]=""
return 

rem --- Delete a line at LINE
delete_line: 
    for z=line to numlines
        let lines$[z]=lines$[z+1]
    next z
    let lines$[numlines]="",numlines=numlines-1
return 

rem --- Functions
def fnerror$(q$,q)=q$+" (Line "+str(q:"0000")+")"
def fndatestamp$(q)=DATE(0:"%Mz/%Dz/%Y %hz:%mz:%sz")+" "

rem --- Exit utility
the_end: 
    run "adx_codeportexit.bbj",err=finished
finished: 
end