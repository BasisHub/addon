rem adx - CodePort Program Conversion Utility (Conversion Overlay)
rem Program adx_codeportconv.bbj v8.0.0 12Oct2007
rem 
rem  +-----------------------------------------+
rem  | AddonSoftware Version 8.0.0 - 01Feb2006 |
rem  |  Copyright (c) 1981-2006 AddonSoftware  |
rem  |          All Rights Reserved            |
rem  +-----------------------------------------+
rem 
rem --- Initializations
    dim iolists$[99],resets$[99]
    let iolists=0,resets=0
    let when$=DATE(0:"%Dz%Ms%Y"),app$=cvs(basename$(1,2),8)
    let resetverbs$="resetclearbeginstart"

rem --- Always make sure ads-01 gets opened and application
rem --- parameter record is read.
    let parm$=app$,iolists=iolists+1
    if app$="op" then let parm$="ar"
    if app$="po" then let parm$="ap"
    let rec$=parm$+"s01a: (Generated by CodePort)"
    if app$="sy" then let rec$="sys01t: (Generated by CodePort)"
    let iolists$[iolists]=rec$
    if pos(app$="bmopposf",2)=0 then goto convert_program
    rem --- Additional required parameters
    if app$="bm" then let parm$="iv"
    if app$="op" then let parm$="iv"
    if app$="po" then let parm$="iv"
    if app$="sf" then let parm$="iv"
    let rec$=parm$+"s01a: (Generated by CodePort)"
    let iolists=iolists+1
    let iolists$[iolists]=rec$

rem --- Convert program
convert_program: 
    rem --- Convert line number references to labels
    gosub convert_linenumbers
    rem --- Convert program from executable to source listing
    gosub bbjlst
    rem --- Load source listing
    gosub load_sourcecode
    rem --- Convert to lower case
    gosub lower_case
    rem --- Replace standard sections with temporary #include's
    gosub std_includes
    rem --- Replace standard date handing functions
    gosub replace_functions
    rem --- Formatting comments
    gosub format_comments
    rem --- Update copyright
    gosub update_copyright
    rem --- Remove any statements beginning with a reset verb
    gosub remove_resets
    rem --- Move labels
    gosub move_labels
    rem --- Process simple LET statements
    gosub let_statements
    rem --- Indent code as necessary
    gosub indent_code
    rem --- Store IOLIST's
    gosub store_iolists
    rem --- Check code for channel references not using an IOLIST
    gosub channel_references
    let channel_lines=numlines
    rem --- Parse IOLIST's and build variable table
    gosub parse_iolists
    rem --- Replace IOLIST references with record/template processing"
    gosub iolist_references
    rem --- Remove IOLIST statements
    gosub REMOVE_IOLISTS
    rem --- Combine labels
    gosub combine_labels
    rem --- Remove THEN clause from the IF statements
    gosub remove_thens
    rem --- Indent all code per new v8.x standard
    gosub final_indenting
    rem --- Search and replace code as indicated in replacements.ini
    gosub replace_code
    rem --- Replace #include's with actual code
    gosub replace_includes
    rem --- Insert program initialization code
    gosub program_initializations
    rem --- Remove any extra blank lines
    gosub remove_blanklines

rem --- Run the next overlay
next_overlay: 
    run "adx_codeportlbls.bbj",err=the_end

rem --- Convert line number references to labels
convert_linenumbers: 
    let message$="Converting "+pathname$+"..."
    gosub display_message
    let description$="Converting line number references to labels..."
    gosub display_step
    let tmpfile$=pgmdir$+basename$+tmp$
    call "_label",pathname$,tmpfile$,status$,1
    gosub display_done
return


rem --- Convert program from executable to source listing
bbjlst: 
    let description$="Creating source listing from program executable..."
    gosub display_step
    rem --- let command$=pro5lst$+" -w1024 -l "+tmpfile$
    command$="bbjlst.exe -w1024 -l "+tmpfile$
    let x=scall(command$)
    let tmpfile$=pgmdir$+basename$,txtfile$=basename$+txt$
    erase pgmdir$+basename$+txt$,err=rename_tmpfile
    rename_tmpfile: rename tmpfile$,txtfile$
    let txtfile$=pgmdir$+basename$+txt$,tmpfile$=tmpfile$+tmp$
    gosub display_done
return


rem --- Load source listing
load_sourcecode:
    dim lines$[9999]
    let description$="Loading source listing..."
    gosub display_step
    let txt_dev=unt,numlines=0
    open (txt_dev)txtfile$

    rem --- Top of source code read loop
    next_txt: 
        read (txt_dev,end=load_sourcecode_exit)rec$
        let rec$=cvs(rec$,2)
        if rec$="" then goto next_txt
        let l=len(rec$),linenum=0
        if l<7 then goto store_line
        if l>5 then let linenum=num(rec$(1,5),err=store_line)
        if linenum then if rec$(6,1)<>":" then goto store_line
        let rec$=cvs(rec$(7),2)
        let lines$[numlines]=lines$[numlines]+rec$
    goto next_txt

    rem --- Store the line
    store_line: 
        let numlines=numlines+1
        let lines$[numlines]=rec$
        goto next_txt

    load_sourcecode_exit: 
        gosub display_done
        let original=numlines
return

rem --- Convert to lower case
lower_case: 
    let description$="Performing case conversion..."
    gosub display_step
    close (txt_dev)
    erase txtfile$
    string txtfile$
    open (txt_dev)txtfile$
    for x=1 to numlines
        let rec$=str(100000+x:"000000-")+lines$[x]
        for i=1 to len(rec$)
            if mod(pos($22$=rec$(1,i),1,0),2)=0 rec$(i,1)=cvs(rec$(i,1),8)
        next i
        write (txt_dev)rec$
    next x
    close (txt_dev)
    gosub load_sourcecode

    rem --- Strip line numbers from each line and store it
    for x=1 to numlines
        let lines$[x]=lines$[x](8)
    next x
    rem --- Delete the EXECUTE'd lines
    rem delete 100000,199999
    gosub display_done
return 

rem --- Replace standard sections with temporary #include's
std_includes: 
    let description$="Replacing standard program sections with #include's..."
    let action=2,options$[1]=basename$
    gosub modify_code
return 

rem --- Remove any existing date functions
replace_functions: 
    let description$="Replacing standard date handling functions..."
    let action=3
    gosub modify_code
return

rem --- Formatting comments
format_comments: 
    let description$="Formatting comment lines..."
    let action=4,options$[1]=basename$
    gosub modify_code
return 

rem --- Update copyright
update_copyright: 
    let action=2
    let description$="Updating program copyright..."
    gosub initializations
return 

rem --- Move labels to separate line (except rem's)
move_labels: 
    let description$="Moving labels..."
    let action=6
    gosub modify_code
return 

rem --- Process simple LET statements
    let_statements: 
    let description$="Processing simple LET statements..."
    let action=7
    gosub modify_code
return 

rem --- Indent code where necessary
indent_code: 
    let description$="Indenting code as necessary..."
    let action=8
    gosub modify_code
return 

rem --- Storing IOLIST's
store_iolists: 
    let description$="Storing IOLIST's..."
    gosub display_step
    for x=1 to numlines
        let rec$=cvs(lines$[x],8),stored=0
        if pos(": iolist"=rec$)=0 or pos("sys01"=rec$) then continue
        for z=1 to iolists
            if rec$(1,6)=iolists$[z](1,6) then let stored=1
        next z
        if stored=0 then let iolists=iolists+1,iolists$[iolists]=rec$
    next x
    gosub display_done
return

rem --- Check code for channel references not using an IOLIST
channel_references: 
    let description$="Checking for channel references..."
    gosub display_step
    for x=1 to numlines
        let rec$=cvs(lines$[x],1+2+8)
        dev_check: 
        let z=pos("rem "=rec$),p=pos("_dev"=rec$)
        if p=0 then continue
        if z then if p>z then continue
        let b=p-5,l=min(p+3,len(rec$))
        if b<1 then continue
        let x$=rec$(b,l-b+1),x$=x$(1,5),rec$=rec$(l+1),b=0
        if pos(x$(1,2)="aparbmglivmpoppoprsasfsy",2)=0 then let x$=iolists$[1](1,5)
        for z=1 to iolists
            if x$=iolists$[z](1,5) then let b=z
        next z
        if b=0 then let iolists=iolists+1,iolists$[iolists]=fnerror$(x$+"a: Channel reference",x)
        if cvs(rec$,2)<>"" then goto dev_check
    next x
    gosub display_done
return 

rem --- Parse IOLIST's (Not implemented/Reserved for future use)
parse_iolists: 
return 

rem --- Insert initialization code
program_initializations: 
    let action=0
    if basename$(3,1)="c" then let action=1
    let description$="Inserting program initialization code..."
    gosub initializations
return 

rem --- Replace IOLIST's with record/template processing
iolist_references: 
    let description$="Replacing iolist's with record/template processing..."
    let action=9
    gosub modify_code
return 

rem --- Remove IOLIST lines
remove_iolists: 
    let description$="Removing IOLIST statements..."
    let action=10
    gosub modify_code
return 

rem --- Combine labels with previous comment where possible
combine_labels: 
    let description$="Building combined paragraphs..."
    let action=11
    gosub modify_code
return 

rem --- Remove the then clause from if statements
remove_thens: 
    let description$="Removing the THEN clause from IF statements..."
    let action=12
    gosub modify_code
return 

rem --- Perform final formatting
final_indenting: 
    let description$="Performing final formatting..."
    let action=13
    gosub modify_code
return 

rem --- Remove any extra blank lines
remove_blanklines: 
    let description$="Removing extraneous blank lines..."
    let action=14
    gosub modify_code
return 

rem --- Search and replace code as indicated in replacements.ini
replace_code: 
    let description$="Replacing code fragments as required..."
    gosub display_step
    for x=1 to numlines
        let rec$=lines$[x]
        for y=1 to replacements
            replacement_test: 
            let p=pos(oldcode$[y]=rec$),l=len(oldcode$[y])
            if p=0 then goto next_replacement
            let rec$=rec$(1,p-1)+newcode$[y]+rec$(p+l)
            goto replacement_test
            next_replacement: 
        next y
        let lines$[x]=rec$
    next x
    rem --- Search and replace completed
    gosub display_done
return 

rem --- Replace #include's with actual code
replace_includes: 
    if replace_includes=0 then goto replace_includes_skipped
    let description$="Replacing #include's with actual code...",lowest=1
    gosub display_step
    replace_pass: 
    let includes=0
    for x=1 to numlines
        let rec$=lines$[x],p=pos("#include"=rec$),inc_dev=0
        if p<>1 then goto next_include_x
        let include$=cvs(rec$(p+9),1+2),inc_dev=unt,includes=1
        if lowest=1 then let lowest=x
        open (inc_dev)libdir$+include$
        let line=x
        gosub delete_line
        next_include_line: 
            read (inc_dev,end=next_include)rec$
            let rec$=cvs(rec$,2)
            if rec$="" then if pos("rem"=lines$[x-1])=0 then goto next_include_line
            if pos("rem"=rec$)=1 then if pos("rem"=lines$[x-1]) then goto next_include_line
            let lines$[x]=rec$,x=x+1,line=x
            gosub insert_line
            goto next_include_line
        next_include: 
            close (inc_dev,err=next_include_x)
        next_include_x: 
    next x
    if includes then goto replace_pass
    for x=lowest to numlines
        let rec$=cvs(lines$[x],2)
        if pos("rem"=rec$)<>1 then goto next_insert_rem
        if cvs(lines$[x-1],2)="" then goto next_insert_check
        if pos("rem"=cvs(lines$[x-1],2)) then goto next_insert_rem
        let line=x,x=x+1
        gosub insert_line
        goto next_insert_rem
        next_insert_check: 
        if pos("rem"=cvs(lines$[x-2],2))=0 then goto next_insert_rem
        let line=x-1
        gosub delete_line
        next_insert_rem: 
    next x
    gosub display_done
    replace_includes_skipped: 
return 

rem --- Remove any reset statements (RESET, CLEAR, BEGIN and START)
remove_resets: 
    let description$="Searching for reset verbs..."
    gosub display_step
    for line=1 to numlines
        let rec$=cvs(lines$[line],1+2)
        let l=len(rec$)
        if len(rec$)<5 then continue
        let x$=rec$(1,5)
        let p=pos(x$=resetverbs$,5)
        if p=0 then continue
        let l=min(12,l)
        let x$=cvs(resetverbs$(p,5),4)+" statement removed ["+rec$(1,l)+"]"
        let resets=resets+1
        let resets$[resets]=fnerror$(x$,line)
        gosub delete_line
        let line=max(1,line-1)
    next line
    gosub display_done
return 

rem --- Call adc_codeportconv.bbx to perform the requested action
modify_code: 
    gosub display_step
    call "adc_codeportconv.bbj",action,lines$[all],options$[all],numlines
    gosub display_done
return 

rem --- Call adc_codeportint.bbx to perform initializations
initializations: 
    gosub display_step
    let options$[1]=basename$,options$[2]=newname$,options$[3]=when$
    let options$[4]=utility$,options$[5]=version$,options$[6]=arguments$
    call "adc_codeportinit.bbj",action,options$[all],lines$[all],numlines,iolists$[all],iolists
    gosub display_done
return 

rem --- Display range of LINES$ (debugging tool)
listlines: 
    for x=b to e
        print "(",x:"0000","): ",lines$[x]
    next x
    escape 
return 

rem --- Display message
display_message: 
    print fndatestamp$(0),message$
    print (log_dev)fndatestamp$(0),message$,cr$
return 

rem --- Display step
display_step: 
    let message$=description$
    gosub display_message
return 

rem --- Display step completion
display_done: 
    let message$=description$+"completed"
    gosub display_message
return 

rem --- Insert a blank line at LINE
insert_line: 
    let numlines=numlines+1
    for z=numlines to line+1 step -1
        let lines$[z]=lines$[z-1]
    next z
    let lines$[line]=""
return 

rem --- Delete a line at LINE
delete_line: 
    for z=line to numlines
        let lines$[z]=lines$[z+1]
    next z
    let lines$[numlines]="",numlines=numlines-1
return 

rem --- Functions
def fnerror$(q$,q)=q$+" (Line "+str(q:"0000")+")"
def fndatestamp$(q)=DATE(0:"%Mz/%Dz/%Y %hz:%mz:%sz")+" "

rem --- Exit utility
the_end: 
    run "adx_codeportexit.bbj",err=finished
finished: 
end