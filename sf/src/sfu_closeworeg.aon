rem --- Closed Work Order Update
rem --- Program sfu_ca v8.0.0 21Jan2008 (sfu_ca)
rem --- Created by c:\codeport_bbj\adx_codeport.bbj v1.1.5 (01/21/2008 09:38:24)

rem --- AddonSoftware Version 8.0.0 - 01Jan2007
rem --- Copyright (c) 1981-2007 AddonSoftware
rem --- All Rights Reserved

        next_overlay$="";rem --- clear next_var and outvect! so bas_process_end doesn't loop...i.e., don't run anything after this
        if OutVect!<>null() OutVect!=null()

        setesc std_error
        seterr std_error

rem --- Retrieve the program path

        pgmdir$=stbl("+DIR_PGM",err=*next)

rem --- Retrieve sysinfo data

        sysinfo_template$=stbl("+SYSINFO_TPL",err=*next)
        dim sysinfo$:sysinfo_template$
        sysinfo$=stbl("+SYSINFO",err=*next)
        milestone=num(stbl("+MILESTONE",err=*next),err=*next)
        firm_id$=sysinfo.firm_id$

rem --- Open/Lock files

        files=34,begfile=1,endfile=files
        dim files$[files],options$[files],ids$[files],templates$[files],channels[files]
        files$[1]="arc_termcode",ids$[1]="ARC_TERMCODE"
        files$[2]="ars_params",ids$[2]="ARS_PARAMS"
        files$[3]="glm-01",ids$[3]="GLM_ACCT"
        files$[4]="gls_params",ids$[4]="GLS_PARAMS"
        files$[5]="glt-04",ids$[5]="GLE_DAILYDETAIL"
        files$[6]="ivm-01",ids$[6]="IVM_ITEMMAST"
        files$[7]="ivm-02",ids$[7]="IVM_ITEMWHSE"
        files$[8]="ivm-04",ids$[8]="IVM_ITEMTIER"
        files$[9]="ivm-07",ids$[9]="IVM_LSMASTER"
        files$[10]="ivm-08",ids$[10]="IVX_LSXREF"
        files$[11]="ivm-12",ids$[11]="IVM_ITEMACT"
        files$[12]="ivm-17",ids$[12]="IVM_LSACT"
        files$[13]="ivs_params",ids$[13]="IVS_PARAMS"
        files$[14]="ivt-01",ids$[14]="IVT_LSTRANS"
        files$[15]="ivt-02",ids$[15]="IVX_LSCUST"
        files$[16]="ivt-04",ids$[16]="IVT_ITEMTRAN"
        files$[17]="ope-11",ids$[17]="OPE_ORDDET"
        files$[18]="sfe-01",ids$[18]="SFE_WOMASTR"
        files$[19]="sfe-02",ids$[19]="SFE_WOOPRTN"
        files$[20]="SFE_CLSDTRANS",ids$[20]="SFE_CLSDTRANS"
        files$[21]="sfe-06",ids$[21]="SFE_WOLOTSER"
        files$[22]="sfe-13",ids$[22]="SFE_WOMATHDR"
        files$[23]="sfe-15",ids$[23]="SFE_WOMATISH"
        files$[24]="sfe-22",ids$[24]="SFE_WOMATL"
        files$[25]="sfe-23",ids$[25]="SFE_WOMATDTL"
        files$[26]="sfe-25",ids$[26]="SFE_WOMATISD"
        files$[27]="sfe-32",ids$[27]="SFE_WOSUBCNT"
        files$[28]="sfm-05",ids$[28]="SFE_WOSCHDL"
        files$[29]="sfm-06",ids$[29]="SFX_WOSCHDXR"
        files$[30]="sfm-10",ids$[30]="SFC_WOTYPECD"
        files$[31]="sfs_params",ids$[31]="SFS_PARAMS"
        files$[32]="sft-01",ids$[32]="SFT_OPNOPRTR"
        files$[33]="sft-21",ids$[33]="SFT_OPNMATTR"
        files$[34]="sft-31",ids$[34]="SFT_OPNSUBTR"
        call pgmdir$+"adc_fileopen.aon",action,begfile,endfile,files$[all],options$[all],
:                                   ids$[all],templates$[all],channels[all],batch,status
        if status goto std_exit
        arm10_dev=channels[1]
        ars01a_dev=channels[2]
        glm01_dev=channels[3]
        gls01a_dev=channels[4]
        glt04_dev=channels[5]
        ivm01_dev=channels[6]
        ivm02_dev=channels[7]
        ivm04_dev=channels[8]
        ivm07_dev=channels[9]
        ivm08_dev=channels[10]
        ivm12_dev=channels[11]
        ivm17_dev=channels[12]
        ivs01a_dev=channels[13]
        ivt01_dev=channels[14]
        ivt02_dev=channels[15]
        ivt04_dev=channels[16]
        ope11_dev=channels[17]
        sfe01_dev=channels[18]
        sfe02_dev=channels[19]
        sfe04_dev=channels[20]
        sfe06_dev=channels[21]
        sfe13_dev=channels[22]
        sfe15_dev=channels[23]
        sfe22_dev=channels[24]
        sfe23_dev=channels[25]
        sfe25_dev=channels[26]
        sfe32_dev=channels[27]
        sfm05_dev=channels[28]
        sfm06_dev=channels[29]
        sfm10_dev=channels[30]
        sfs01a_dev=channels[31]
        sft01_dev=channels[32]
        sft21_dev=channels[33]
        sft31_dev=channels[34]

rem --- Dimension string templates

    dim arm10a$:templates$[1],ars01a$:templates$[2],glm01a$:templates$[3],
:       gls01a$:templates$[4],glt04a$:templates$[5],ivm01a$:templates$[6],
:       ivm02a$:templates$[7],ivm04a$:templates$[8],ivm07a$:templates$[9],
:       ivm08a$:templates$[10],ivm12a$:templates$[11],ivm17a$:templates$[12],
:       ivs01a$:templates$[13],ivt01a$:templates$[14],ivt02a$:templates$[15],
:       ivt04a$:templates$[16],ope11a$:templates$[17],sfe01a$:templates$[18],
:       sfe02a$:templates$[19],sfe04b$:templates$[20],sfe06a$:templates$[21],
:       sfe13a$:templates$[22],sfe15a$:templates$[23],sfe22a$:templates$[24],
:       sfe23a$:templates$[25],sfe25a$:templates$[26],sfe32a$:templates$[27],
:       sfm05a$:templates$[28],sfm06a$:templates$[29],sfm10a$:templates$[30],
:       sfs01a$:templates$[31],sft01a$:templates$[32],sft21a$:templates$[33],
:       sft31a$:templates$[34]



rem --- Retrieve parameter records

        ars01a_key$=firm_id$+"AR00"
        find record (ars01a_dev,key=ars01a_key$,err=std_missing_params) ars01a$
        gls01a_key$=firm_id$+"GL00"
        find record (gls01a_dev,key=gls01a_key$,err=std_missing_params) gls01a$
        ivs01a_key$=firm_id$+"IV00"
        find record (ivs01a_dev,key=ivs01a_key$,err=std_missing_params) ivs01a$
        sfs01a_key$=firm_id$+"SF00"
        find record (sfs01a_dev,key=sfs01a_key$,err=std_missing_params) sfs01a$



rem --- Parameters

        dim g[4],desc[3]
        dim params[0],params$[4],items$[3],refs$[11],refs[5],ivfiles[44]
        n2$="SF",gl$="N",r9$="N",op$="N"
        find record (sfs01a_dev,key=firm_id$+n2$+"00",dom=std_missing_params) sfs01a$
        op$=sfs01a.ar_interface$
        find record (gls01a_dev,key=firm_id$+"GL00",dom=std_missing_params) gls01a$
        find record (ivs01a_dev,key=firm_id$+"IV00",dom=std_missing_params) ivs01a$
        ivs01_precision=num( ivs01a.precision$)
        g[4]=num(gls01a.max_acct_len$)
        if sfs01a.ar_interface$="Y" 
             call pgmdir$+"adc_application.aon","AR",info$[all]
             if info$[20]="Y" 
                 find record (ars01a_dev,key=firm_id$+"AR00",dom=call_adc_application) ars01a$
                 r9$=ars01a.dist_by_item$
                 op$="Y"
             endif 
       endif
call_adc_application:

        call pgmdir$+"adc_application.aon",n2$,info$[all]
        gl$=info$[9]

        for i=1 to 3
            let desc[i] = num(FIELD(ivs01a$,"desc_len_"+str(i:"00")))
        next i


        param2$=str(ivs01a.item_id_len:"00")
        param2$=param2$+str(ivs01a.vendor_prd_len:"00")
        param2$=param2$+ivs01a.precision$
        param2$=param2$+ivs01a.reserved_str$
        param2$=param2$+str(ivs01a.ls_no_len:"00")
        for i=1 to 3
            param2$=param2$+FIELD(ivs01a$,"desc_len_"+str(i:"00"))
        next i
        for i=1 to 3
            param2$=param2$+FIELD(ivs01a$,"user_desc_lb_"+str(i:"00"))
        next i
        for i=1 to 3
            param2$=param2$+FIELD(ivs01a$,"master_flag_"+str(i:"00"))
        next i

        param3$=ivs01a.multi_whse$
        param3$=param3$+ivs01a.lifofifo$
        param3$=param3$+ivs01a.warehouse_id$
        param3$=param3$+ivs01a.cost_method$
        param3$=param3$+ivs01a.auto_no_iv$
        param3$=param3$+ivs01a.label_across$
        param3$=param3$+ivs01a.label_length$
        param3$=param3$+ivs01a.label_width$
        param3$=param3$+ivs01a.lotser_flag$

        param4$=ivs01a.current_per$
        param4$=param4$+ivs01a.current_year$

rem --- Init Data

        params$[0]=sysinfo.system_date$
        params$[1]=sysinfo.user_id$
        params$[2]=param2$
        params$[3]=param3$
        params$[4]=param4$
        more=1
        call stbl("+DIR_SYP")+"bac_key_template.bbj","SFT_OPNOPRTR","PRIMARY",sft01_key_tpl$,rd_table_chans$[all],status$
        call stbl("+DIR_SYP")+"bac_key_template.bbj","SFT_OPNMATTR","PRIMARY",sft21_key_tpl$,rd_table_chans$[all],status$
        call stbl("+DIR_SYP")+"bac_key_template.bbj","SFT_OPNSUBTR","PRIMARY",sft31_key_tpl$,rd_table_chans$[all],status$
        call stbl("+DIR_SYP")+"bac_key_template.bbj","SFE_WOOPRTN","PRIMARY", sfe02_key_tpl$,rd_table_chans$[all],status$
        call stbl("+DIR_SYP")+"bac_key_template.bbj","SFE_WOMATL","PRIMARY",  sfe22_key_tpl$,rd_table_chans$[all],status$
        call stbl("+DIR_SYP")+"bac_key_template.bbj","SFE_WOSUBCNT","PRIMARY",sfe32_key_tpl$,rd_table_chans$[all],status$
        call stbl("+DIR_SYP")+"bac_key_template.bbj","SFE_WOMATDTL","PRIMARY",sfe23_key_tpl$,rd_table_chans$[all],status$
        call stbl("+DIR_SYP")+"bac_key_template.bbj","SFE_CLSDTRANS","PRIMARY",sfe04_key_tpl$,rd_table_chans$[all],status$
        call stbl("+DIR_SYP")+"bac_key_template.bbj","SFE_WOMATISD","PRIMARY",sfe25_key_tpl$,rd_table_chans$[all],status$
        call stbl("+DIR_SYP")+"bac_key_template.bbj","SFX_WOSCHDXR","PRIMARY",sfm06_key_tpl$,rd_table_chans$[all],status$

rem --- Options

        msg_id$="AON_UPDT_QUERY"
        dim x$:stbl("+SYSINFO_TPL")
        dim msg_tokens$[1]
        x$=stbl("+SYSINFO")                                                            
        msg_tokens$[1]=x.task_desc$
        gosub disp_message
        if msg_opt$<>"Y" then goto std_exit
        call pgmdir$+"adc_progress.aon","N","","","","",0,sfe04_dev,1,meter_num,status

rem --- Disallow 'M'enu option in Error Routine

        exit_ctrl=1

rem --- Initial Read

        read (sfe04_dev,key=firm_id$+"  "+"B",dom=*next)
        dim  sfe04_key$:sfe04_key_tpl$
        while more
                sfe04_key$=key(sfe04_dev,end=*break)
                if sfe04_key.firm_id$<>firm_id$ and sfe04_key.wo_location$<>"  " 
:                  and sfe04_key.record_id_a$<>"B" then break

                extract record (sfe01_dev,key=sfe04_key.firm_id$+sfe04_key.wo_location$+sfe04_key.wo_no$,dom=remove_sfe04) sfe01a$
                if sfe01a.wo_category$="R" then 
                    read (sfe04_dev)
                    continue
                endif

                call pgmdir$+"adc_progress.aon","S","","","","",0,0,1,meter_num,status
                refs$[1]=sfe01a.customer_id$
                refs$[2]=sfe01.order_no$
                refs$[3]=sfe01a.wo_no$
                refs$[4]=sfe01a.wo_type$

rem --- Calc Actuals From Transactions

            dim d[4],t[5]
            wotran_dev=sft01_dev
            dim sftran$:tmpl(wotran_dev)
            dim  wotran_key$:sft01_key_tpl$
            record_id1$=sft01.record_id_o$ 
            field3=sftran.direct_date
             

            while more
                 read (wotran_dev,key=sfe01a.firm_id$+sfe01a.wo_location$+sfe01a.wo_no$,dom=*next)
                 while more

                        wotran_key$=key(wotran_dev,end=*break)
                        if wotran_key.firm_id$+wotran_key.wo_location$+wotran_key.wo_no$<>sfe01a.firm_id$+sfe01a.wo_location$+sfe01a.wo_no$ then break
                        read record (wotran_dev,key=wotran_key$) sftran$
                        x=pos(record_id1$="MS")+2
                        if x>2 then 
                            let d[x]=d[x]+sft01a.ext_cost
                        else
                            d[1]=d[1]+sftran.units*sftran.direct_date
                            d[2]=d[2]+sftran.ext_cost-sftran.units*sftran.direct_date
                        endif
                        d[0]=d[0]+sftran.ext_cost
                 wend 

                    if wotran_dev=sft01_dev then 
                       wotran_dev=sft21_dev
                       dim sftran$:tmpl(wotran_dev) 
                       dim  wotran_key$:sft21_key_tpl$
                       record_id1$=sft21.record_id_m$ 
                       field3=sftran.reserved_num
                    else
                        if wotran_dev=sft21_dev then 
                           let wotran_dev=sft31_dev
                           dim sftran$:tmpl(wotran_dev)
                           dim  wotran_key$:sft31_key_tpl$
                           record_id1$=sft31.record_id_s$  
                           field3=sftran.reserved_num
                        endif 
                    endif
             wend

             t[0]=d[0]-sfe01a.cls_cst_todt
             t[0]=-t[0],t[1]=sfe01a.cls_inp_qty*sfe01a.closed_cost; rem "CALC TOTALS
             find record (sfm10_dev,key=firm_id$+"A"+sfe01a.wo_type$,dom=*next) sfm10a$

             if sfe01a.wo_category$="I" 
                  
rem --- Determine GL Posting Accounts

                read record (ivm01_dev,key=firm_id$+sfe01a.item_id$,dom=update_onorder_qty) ivm01a$
                if r9$<>"Y" then let y2$=ivm01a.gl_inv_acct$
                read record (ivm02_dev,key=firm_id$+sfe01a.warehouse_id$+sfe01a.item_id$,dom=update_onorder_qty) ivm02a$
                if r9$="Y" then gosub item_distribution_code
                sfm10a.gl_close_to$=y2$

update_onorder_qty: rem --- Update Item ON ORDER Quantity

                action$="OO"
                items$[0]=firm_id$,items$[1]=sfe01a.warehouse_id$
                items$[2]=sfe01a.item_id$
                refs$[0]=sfe01a.cls_inp_date$
                refs$[3]=sfe01a.wo_no$
                items$[3]=""
                close_qty=sfe01a.cls_inp_qty
                scheduled_wo_total=sfe01a.sch_prod_qty
                closed_prior=sfe01a.qty_cls_todt
                if scheduled_wo_total>=0 then 
                   let sign=1 
                else 
                   let sign=-1
                endif
                if sfe01a.complete_flg$="Y" then 
                    let refs[0]=-(sign*max(0,min(sign*scheduled_wo_total,sign*(scheduled_wo_total-closed_prior))))
                endif
                if sfe01a.complete_flg$="N" and sign*close_qty>=0 then 
                  let refs[0]=-(sign*max(0,min(sign*close_qty,sign*(scheduled_wo_total-closed_prior))))
                endif
                if sfe01a.complete_flg$="N" and sign*close_qty<0 then 
                  let refs[0]=-(sign*max(sign*close_qty,sign*(close_qty+closed_prior-scheduled_wo_total)))
                endif
                gosub update_inventory

rem --- Update Item ISSUED Quantity

                action$="WO"
                refs$[0]=sfe01a.cls_inp_date$
                items$[3]=""
                if sfe01a.lotser_item$<>"Y" 
                    refs[0]=sfe01a.cls_inp_qty
                    refs[1]=sfe01a.closed_cost
                    gosub update_inventory
                endif 
            endif
rem --- Serial/Lotted
            if sfe01a.lotser_item$="Y" 
                read (sfe06_dev,key=sfe01a.firm_id$+sfe01a.wo_location$+sfe01a.wo_no$,dom=*next)
                while more
                    k1$=key(sfe06_dev,end=do_variances)
                    if pos(sfe01a.firm_id$+sfe01a.wo_location$+sfe01a.wo_no$=k1$)=1 
                        read record (sfe06_dev,key=k1$) sfe06a$
                        if sfe06a.cls_inp_qty=0 
                            if sfe01a.complete_flg$<>"Y" and sfe06a.complete_flg$<>"Y" 
                                continue
                            endif
                        endif     
rem --- Update Lot ISSUED Quantity
                        refs[0]=sfe06a.cls_inp_qty
                        refs[1]=sfe06a.closed_cost,items$[3]=sfe06a.lotser_no$
                        gosub update_inventory
rem --- History Here

                    if sfe01a.complete_flg$="Y" then let sfe06a.complete_flg$="Y"
                    if sfe06a.complete_flg$="Y" and sfe06a.closed_flag$<>"Y" then 
                        sfe06a.closed_flag$="Y"
                        sfe06a.closed_date$=sfe01a.cls_inp_date$
                    endif
                    if sfe06a.cls_inp_qty<>0 then 
                         sfe06a.qty_cls_totd=sfe06a.qty_cls_totd+sfe06a.cls_inp_qty
                         sfe06a.cls_cst_totd=sfe06a.cls_cst_totd+sfe06a.cls_inp_qty*sfe06a.closed_cost
                         sfe06a.cls_inp_qty=0
                         sfe06a.closed_cost=0
                    endif
                    write record (sfe06_dev,key=sfe06a.firm_id$+sfe06a.wo_location$+sfe06a.wo_no$+sfe06a.sequence_no$) sfe06a$
                wend
            endif
do_variances: rem --- Do Variances Here
             if sfe01a.complete_flg$<>"Y" then 
                let t[0]=-t[1]
             else
                if sfm10a.stdact_flag$="A" then 
                    let t[1]=d[0]-sfe01a.cls_cst_todt
                else
rem --- Calc Standards
                    dim e[4]
                    sfreq_dev=sfe02_dev  
                    dim sfreqa$:tmpl(sfreq_dev) 
                    dim  sfreq_key$:sfe02_key_tpl$
                    record_id$=sfe02.record_id_a$
                    while more
                        read (sfreq_dev,key=sfe01a.firm_id$+sfe01a.wo_location$+sfe01a.wo_no$,dom=*next)
                        while more
                            sfreq_key$=key(sfreq_dev,end=*break)
                            if sfreq_key.firm_id$+sfreq_key.wo_location$+sfreq_key.wo_no$<>sfe01a.firm_id$+sfe01a.wo_location$+sfe01a.wo_no$ then break
                            read record (sfreq_dev,key=sfreq_key$) sfreqa$
                            x=pos(record_id$="BC")+2
                            if x>2 then 
                                let e[x]=e[x]+sfe02a.tot_std_cost
                            else
                                e[1]=e[1]+sfe02a.total_time*sfe02a.direct_rate
                                e[2]=e[2]+sfe02a.tot_std_cost-sfe02a.total_time*sfe02a.direct_rate
                            endif 
                            e[0]=e[0]+sfe02a.tot_std_cost
                        wend

                        if sfreq_dev=sfe02_dev then 
                            let sfreq_dev=sfe22_dev
                            dim sfreqa$:tmpl(sfreq_dev)
                            dim  sfreq_key$:sfe22_key_tpl$
                            record_id$=sfe22.record_id_a$
                        else
                            if sfreq_dev=sfe22_dev then 
                                let sfreq_dev=sfe32_dev
                                dim sfreqa$:tmpl(sfreq_dev) 
                                dim  sfreq_key$:sfe32_key_tpl$
                                record_id$=sfe32.record_id_a$
                                continue
                            endif
                        endif
                    wend

rem --- Calc Variances
                    precision 2
                    if e[0]=0 then 
                            let y0=0
                    else
                        if sfe01a.wo_category$<>"I" 
:                                     and ((sfe01a.sch_prod_qty=sfe01a.qty_cls_todt+sfe01a.cls_inp_qty) or 
:                                      e[0]=0 or sfe01a.recalc_flag$="N") then 
                            let y0=sfe01a.cls_inp_qty*sfe01a.closed_cost+sfe01a.cls_cst_todt 
                        else    
rem --- Pro-Rate Standards
                            if sfe01a.wo_category$<>"I" then 
                                if sfe01a.sch_prod_qty<>0 then 
                                    let y0=e[0]*(sfe01a.qty_cls_todt+sfe01a.cls_inp_qty)/sfe01a.sch_prod_qty 
                                else 
                                    let y0=0 
                                endif    
                            else
                                let y0=sfe01a.cls_inp_qty*sfe01a.closed_cost+sfe01a.cls_cst_todt
                            endif
                            if y0<>e[0] then 
                                if e[0]=0 then 
                                    let e[1]=0,e[3]=0,e[4]=0    
                                else
                                    e[1]=e[1]*y0/e[0]
                                    e[3]=e[3]*y0/e[0]
                                    e[4]=e[4]*y0/e[0]
                                endif 
                                e[2]=y0-(e[1]+e[4]+e[3])
                            endif
                        endif 
rem --- Calc Variance
                    t[2]=d[1]-e[1]
                    t[4]=d[3]-e[3],t[5]=d[4]-e[4]
                    t[3]=d[0]-(y0+t[2]+t[4]+t[5]); rem "Any left overs goto OH VNCE
                endif
             endif
rem --- Post G/L Here
            precision 2
            sfm10a.gl_wip_acct$=sfm10a.gl_wip_acct$
            sfm10a.gl_close_to$=sfm10a.gl_close_to$
            sfm10a.gl_dir_lab$=""
            sfm10a.gl_ovh_lab$=""
            sfm10a.gl_pur_acct$=""
            sfm10a.gl_lab_var$= sfm10a.gl_lab_var$
            sfm10a.gl_ovh_var$=sfm10a.gl_ovh_var$
            sfm10a.gl_mat_var$= sfm10a.gl_mat_var$
            sfm10a.gl_sub_var$=sfm10a.gl_sub_var$

            for i=0 to 5
                if t[i]=0 then continue
                account$=y1$(i*10+1,10)
                when$=sfe01a.cls_inp_date$,amount=t[i],units=0
                if sfe01a.wo_category$<>"I" 
                      memo$=sfe01a.description_01$ 
                else 
                      memo$=desc$; rem escape where is desc$ coming from?
                endif      
                ref1$="WO "+sfe01a.wo_no$
                ref2$="Whse "+sfe01a.warehouse_id$
                ref3$="Type "+sfe01a.wo_type$
                gosub glpost
            next i

rem --- Complete It
            flag=0
            if sfe01a.complete_flg$<>"Y"  
                    if sfe01a.closed_date$<sfe01a.cls_inp_date$ then  
                        let sfe01a.closed_date$=sfe01a.cls_inp_date$
                    endif
rem --- Post To Customer Order Line Item (Partial)
                    if sfe01a.wo_category$="N" and op$="Y" 
                        precision ivs01_precision
                        extract record (ope11_dev,key=firm_id$+"  "+sfe01a.customer_id$+sfe01a.order_no$+sfe01a.line_no$,dom=custom_order_partial) ope11a$
                        ope11a.unit_cost=sfe01a.closed_cost
                        ope11a.qty_shipped=sfe01a.cls_inp_qty
                        write record (ope11_dev,key=ope11a.firm_id$+ope11a.ar_type$+ope11a.customer_id$+ope11a.order_no$+ope11a.line_no$) ope11a$
                        precision 2
                    endif 
custom_order_partial:
                    sfe01a.qty_cls_todt=sfe01a.qty_cls_todt+sfe01a.cls_inp_qty
                    sfe01a.cls_cst_todt=sfe01a.cls_cst_todt+sfe01a.cls_inp_qty*sfe01a.closed_cost,sfe01a.recalc_flag$=""
                    sfe01a.cls_inp_qty=0
                    sfe01a.closed_cost=0
                    flag=1
            endif 
rem --- Complete, Complete
            if flag=0 then
                gosub r_schedule_detail
                sfe01a.qty_cls_todt=sfe01a.qty_cls_todt+sfe01a.cls_inp_qty
                sfe01a.cls_cst_todt=sfe01a.cls_cst_todt+sfe01a.cls_inp_qty*sfe01a.closed_cost
                sfe01a.wo_status$="C"
                sfe01a.closed_date$=sfe01a.cls_inp_date$

rem --- Post To Customer Order (Complete)

                if sfe01a.wo_category$="N" and op$="Y"  
                    precision ivs01_precision
                    extract record (ope11_dev,key=firm_id$+"  "+sfe01a.customer_id$+sfe01a.order_no$+sfe01a.line_no$,dom=custom_order_complete) ope11a$
                    ope11a.unit_cost=sfe01a.closed_cost
                    ope11a.qty_shipped=sfe01a.cls_inp_qty
                    write record (ope11_dev,key=ope11a.firm_id$+ope11a.ar_type$+ope11a.customer_id$+ope11a.order_no$+ope11a.line_no$) ope11a$
                    precision 2
                endif 
custom_order_complete:
                sfe01a.cls_inp_qty=0
                sfe01a.closed_cost=0

rem --- Reset ivm-02 Committed If All Is Not Issued

                 remove (sfe13_dev,key=sfe01a.firm_id$+sfe01a.wo_location$+sfe01a.wo_no$+"000",dom=*next)
                 read (sfe23_dev,key=sfe01a.firm_id$+sfe01a.wo_location$+sfe01a.wo_no$,dom=*next)
                 while more
                    sfe23_key$=key(sfe23_dev,end=*break)
                    if sfe23_key.firm_id$+sfe23_key.wo_location$+sfe23_key.wo_no$<>sfe01a.firm_id$+sfe01a.wo_location$+sfe01a.wo_no$ then break
                    read record (sfe23_dev,key=sfe23_key$) sfe23a$
                    if sfe23a.qty_ordered<>sfe23a.tot_qty_iss 
                        action$="UC"
                        items$[0]=firm_id$
                        items$[1]=sfe23a.warehouse_id$
                        items$[2]=sfe23a.item_id$
                        refs[0]=sfe23a.qty_ordered-sfe23a.tot_qty_iss 
                        items$[3]=""
                        gosub update_inventory
                    endif 
                    remove (sfe23_dev,key=sfe23_key$,dom=*next)
                 wend 

                remove (sfe15_dev,key=sfe01a.firm_id$+sfe01a.wo_location$+sfe01a.wo_no$+"000",dom=*next)
                read (sfe25_dev,key=sfe01a.firm_id$+sfe01a.wo_location$+sfe01a.wo_no$,dom=*next)
                dim  sfe25_key$:sfe25_key_tpl$
                while more
                    sfe25_key$=key(sfe25_dev,end=*break)
                    if sfe25_key.firm_id$+sfe25_key.wo_location$+sfe25_key.wo_no$<>sfe01a.firm_id$+sfe01a.wo_location$+sfe01a.wo_no$ then break
                    remove (sfe25_dev,key=sfe25_key$)
                wend 
            endif    
            precision ivs01_precision
            write record (sfe01_dev,key=sfe01a.firm_id$+sfe01a.wo_location$+sfe01a.wo_no$) sfe01a$
remove_sfe04: 
            remove (sfe04_dev,key=k0$,dom=*next)
    wend

done: rem --- End

        if gl$="Y" then call pgmdir$+"glc_ctlupdate.aon",status
        goto std_exit

update_inventory: rem --- Update Inventory Information

        call pgmdir$+"ivc_ua.bbx",action$,ivfiles[all],params[all],params$[all],items$[all],refs$[all],refs[all],status
        return


item_distribution_code: rem --- Item Distribution Code
        dim q8$(80,"0")
        find (arm10_dev,key=firm_id$+"D"+ivm02a.ar_dist_code$,dom=label1)*,q8$(1)
        let y2$=q8$(61,10)
label1:
        return

r_schedule_detail:rem --- Remove Schedule Detail Records
        read (sfm06_dev,key=sfe01a.firm_id$+sfe01a.wo_no$,dom=*next)
        dim  sfm06_key$:sfm06_key_tpl$
        while more
            let sfm06_key$=key(sfm06_dev,end=remove_sfm05)
            if pos(sfe01a.firm_id$+sfe01a.wo_no$=sfm06_key$)=1 
remove_sfm06:       remove (sfm06_dev,key=sfm06_key$)
            endif 
remove_sfm05: 
            remove (sfm05_dev,key=sfm06_key.firm_id$+sfm06_key.op_code$+sfm06_key.sched_date$+sfm06_key.wo_no$+sfm06_key.op_seq$,dom=remove_sfm06)
        wend 
        return

rem --- Standard G/L Posting Routine

glpost:
        if gl$<>"Y" then  return
        call pgmdir$+"glc_glpost.aon",glm01_dev,glt04_dev,glt14_dev,account$,when$,ref1$,ref2$,ref3$,memo$,amount,units,status

        return

rem #include disp_message.src

disp_message:rem --- Display Message Dialog

    call stbl("+DIR_SYP")+"bac_message.bbj",msg_id$,msg_tokens$[all],msg_opt$,table_chans$[all]
return
	
rem #endinclude disp_message.src

rem #include std_error.src

std_error: rem --- Standard error handler (01Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    call stbl("+DIR_SYP")+"bac_error.bbj",err=std_error_exit,pgm(-2),str(tcb(5):"00000"),
:                                str(err:"000"),rd_err_text$,rd_err_act$
    if pos("EXIT"=rd_err_act$) goto std_error_exit
    if pos("ESCAPE"=rd_err_act$) seterr 0;setesc 0
    if pos("RETRY"=rd_err_act$) retry
std_error_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_error_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_error_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_error_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_error_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_error.src
rem #include std_missing_params.src

std_missing_params: rem --- Standard missing parameter handler (15Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    pgmdir$=stbl("+DIR_PGM",err=std_missing_params_exit)
    call pgmdir$+"adc_noparams.aon",err=std_missing_params_exit,pgm(-2),str(tcb(5):"00000"),
:                                   str(err:"000"),rd_err_text$,rd_err_act$
std_missing_params_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_missing_params_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_missing_params_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_missing_params_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_missing_params_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_missing_params.src

rem #include std_end.src

std_exit: rem --- Standard program end (01Mar2006)

    call pgmdir$+"adc_progress.aon","D","","","","",0,0,0,meter_num,status
    run stbl("+DIR_SYP")+"bas_process_end.bbj",err=*next
    release

rem #endinclude std_end.src

    end
