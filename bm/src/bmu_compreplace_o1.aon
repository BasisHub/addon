rem --- Bill of Material Component Item Replacement
rem --- Program bmu_db_new v8.0.0 11Feb2008 (bmu_db)
rem --- Created by c:\codeport_bbj\adx_codeport.bbj v1.1.5 (02/11/2008 04:31:49)

rem --- AddonSoftware Version 8.0.0 - 01Jan2007
rem --- Copyright BASIS International Ltd.  All Rights Reserved.
rem --- All Rights Reserved

rem ************************************************************
rem    Phase 1 checks for errors
rem      If there are errors,
rem         - store them in a vector
rem         - send vector to DocOut
rem         - abort processing
rem 
rem      NOTE: We abort processing, rather than changing all bills that
rem            are without error and then reporting the exceptions, because
rem            there could be cases where the task is being run in order 
rem            to change qty required without changing the component's 
rem            item number. In this case, if the task couldn't be safely
rem            re-run after errors were fixed for the same range without
rem            potentially doubling the user's desired modification.
rem 
rem
rem    Phase 2 processes the bills
rem      Each bill is stored in toto (line by line) in a vector.
rem        this is in order to dynamically add/insert the 'New'
rem        replacement item, since in Barista, lines are seq'd by one.
rem      If a materials line of a bill should be replaced
rem         - its obsolete date is modified to be the 
rem           "Effective Date" from options entry from
rem         - a new line is added for the 'New' item with an
rem           effective date = the "Effective Date" from options entry from
rem      If "Obsolete Comments" is Y,
rem         memo lines between any replaced material and the next
rem         material line have their obsolete data set to 
rem         the "Effective Date" from options entry from
rem      If the bill was changed,
rem         - the lines for the bill are deleted (in case of old-style
rem           sequence numbers eg by 5s or by 10s)
rem         - the vector is written back to bmm02 with new sequence
rem           numbers generated by the program (because of the inserts)
rem ************************************************************


    setesc std_error
    seterr std_error

rem --- Retrieve the program path

    pgmdir$=stbl("+DIR_PGM",err=*next)

rem --- Retrieve sysinfo data

    sysinfo_template$=stbl("+SYSINFO_TPL",err=*next)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=*next)
    milestone=num(stbl("+MILESTONE",err=*next),err=*next)
    firm_id$=sysinfo.firm_id$

rem --- Initializations

    precision pre
    more=1
	
	seq_max=999; rem *** Change this if max len of Seq field changes in Datadict
	seq_fld_len=3; rem *** Change this if max len of Seq field changes in Datadict
	item_len=20
	
	call stbl("+DIR_SYP")+"bac_key_template.bbj","BMM_BILLMAT","PRIMARY",bmm02_key_tpl$,rd_table_chans$[all],status$	
	dim bmm02_key$:bmm02_key_tpl$
	
	rem bill_line$ is dim'ed to bmm02a$ template in prev o'lay to hold all recs/lines of a bill	
	
rem --- Progress meter

    call pgmdir$+"adc_progress.aon","N","","","","",0,bmm02_dev,1,meter_num,ignore_status
rem --- Disallow 'M'enu option in Error Routine

    exit_ctrl=1

rem ================================================
rem    Phase One -- Error check
rem
rem     For all bills in range
rem 	- For materials line matching Old item and meeting Date criteria
rem 		- If New item = the bill num or out of seq nums
rem 			- record the error
rem 			- increment error count
rem     - If there are errors
rem         - send error vector to DocOut
rem         - abort processing
rem ================================================

rem --- Phase 1: Inits
	err_seg_len=1+item_len+seq_fld_len; rem Length of each segment of the error$ 
			
rem --- Phase1: Initial Read
	error_cnt=0

	read (bmm02_dev,key=firm_id$+billfrom$,dom=*next)

rem --- Phase 1: Loop thru all bills in range	
	while more; rem Analyze all bills in range for errors
        rem --- Initialize for each bill

			bill_rec_cnt=0; rem Cnt of lines in a bill plus potentially changed lines can't exceed seq_max
			curr_bill$=""
			
		while more; rem Loop thru ea bill for errors. Tally line count along the way
			done_flag=1; rem Flag to stop all loops when End of file, range or Firm
			bmm02_key$=key(bmm02_dev,end=*break)
			done_flag=0; rem Flag to stop all loops when End of file, range or Firm
							
			if pos(firm_id$=bmm02_key$)<>1 then done_flag=1; break
			if billthru$<>"" and bmm02_key.bill_no$>billthru$ then done_flag=1; break

			if curr_bill$="" then
				curr_bill$=bmm02_key.bill_no$
			else
				if curr_bill$<>bmm02_key.bill_no$ then break
			endif	
			
			call pgmdir$+"adc_progress.aon","S","","","","",0,0,1,meter_num,ignore_status
	
			read record (bmm02_dev,key=bmm02_key$) bmm02a$
			bill_rec_cnt=bill_rec_cnt+1; rem Add one for each existing line of a bill
			
			rem --- If obsolete and effective dates don't meet criteria, next rec
				if bmm02a.obsolt_date$<>fill(8) then 
					if bmm02a.obsolt_date$<=effectdate$ then continue; rem Skip if Component obsoleted before Opt Entry Eff Dt
				endif
				if bmm02a.effect_date$<>fill(8) then 
					if bmm02a.effect_date$>effectdate$ then continue; rem Skip if Component not effective until after Opt Entry Eff Dt
				endif
						
			rem --- Check for Materials lines matching Old item
				if bmm02a.item_id$<>olditem$ then continue; rem Skip if wrong item
				
			rem --- Found a line that will be changed
				bill_rec_cnt=bill_rec_cnt+1; rem Add one for the "new" line 
				
			rem --- Store error if the New Item is the same as this Bill Num
				if bmm02_key.bill_no$=newitem$ then 
					let error$=error$+"2"+bmm02_key.bill_no$+bmm02_key.material_seq$; rem "'New' item is same as the bill number.
					error_cnt=error_cnt+1
					continue
				endif		
					
		wend; rem loop for ea bill Phase 1
		        
		rem --- Store error if will exceed max sequence numbers on this bill
			if bill_rec_cnt>seq_max
				let error$=error$+"1"+bmm02_key.bill_no$+bmm02_key.material_seq$; rem "'New' item is same as the bill number.
				error_cnt=error_cnt+1
			endif
			if done_flag then break
	wend; rem loop for all bills Phase 1

If error_cnt then 
	gosub report_errors
	goto std_exit_no_update; rem Report errors and abort processing
endif

rem ================================================
rem    Phase Two -- Component replacement
rem
rem     (Only get here if no errors)
rem 
rem     Process one bill at a time
rem		- Store each line of bill in vector
rem 	    - For materials line matching Old item and meeting Date criteria
rem	       - update Old item's Obsolete and Effective dates in vector
rem 		   - add New item's record to vector
rem 	   	   - If Obsolete Comments, 
rem              obsolete memos for that mat
rem 	    - If the bill was changed
rem 		   - delete mats and memo lines for the bill
rem 		   - write the vector out to bbm02
rem ================================================

rem -- Phase 2: Inits

	rem --- Create an instance of a BBjVector object to store each expanded bill
		rem --- Obtain the instance of the BBjAPI object
			declare BBjAPI BBjAPI!
			LET BBjAPI!=BBjAPI()

		rem --- Create an instance of the BBjVector object
			LET bill_store_vect!=BBjAPI!.makeVector();  rem Holds one whole bill at a time

rem --- Phase 2: Initial Read
	read (bmm02_dev,key=firm_id$+billfrom$,dom=*next)

	dim bmm02_key$:bmm02_key_tpl$
		
	rem bill_line$ is dim'ed to bmm02a$ template in prev o'lay to hold all recs/lines of a bill

rem --- Phase 2: Loop thru all bills in range	

	while more; rem Process all bills in range
        rem --- Initialize for each bill
		    main_should_read=1; rem Memos have nested loop thru bmm-02. Set to zero if memo loop has moved ptr
	        bill_was_changed=0; rem Only write changed bills back to bmm02
			curr_bill$=""
			
		rem --- Clear bill_store vector and make 1-based
			bill_store_vect!.clear()
			bill_store_vect!.addItem(0)
            recs_added=0; rem Number of bmm02 records added to vector
			
		while more; rem Loop for each individual bill in range
			if main_should_read then 
				done_flag=1; rem Flag to stop all loops when End of file, range or Firm
				bmm02_key$=key(bmm02_dev,end=*break)
				done_flag=0
				
				if pos(firm_id$=bmm02_key$)<>1 then done_flag=1; break
				if billthru$<>"" and bmm02_key.bill_no$>billthru$ then done_flag=1; break
				                
				if curr_bill$="" then
					curr_bill$=bmm02_key.bill_no$
				else
					if curr_bill$<>bmm02_key.bill_no$ then break
				endif

				call pgmdir$+"adc_progress.aon","S","","","","",0,0,1,meter_num,ignore_status
		
			    read record (bmm02_dev,key=bmm02_key$) bmm02a$
			    gosub add2vector; rem Store each line of the whole bill in the bill_store_vect! 
		    endif
		    main_should_read=1
		
		    rem --- If obsolete and effective dates don't meet criteria, next rec
			    if bmm02a.obsolt_date$<>fill(8) then 
				    if bmm02a.obsolt_date$<=effectdate$ then continue; rem Skip if Component obsoleted before Opt Entry Eff Dt
			    endif
			    if bmm02a.effect_date$<>fill(8) then 
			    	if bmm02a.effect_date$>effectdate$ then continue; rem Skip if Component not effective until after Opt Entry Eff Dt
			    endif
						
		    rem --- Process Materials lines	
		    	if bmm02a.item_id$<>olditem$ then continue; rem Skip if wrong item
			
			rem --- Found a mat line to change
				bmm02a.obsolt_date$=effectdate$; rem For Old rec, leave Effective and set Obsolete
				gosub mod_vector; rem Update the Old mat line in the bill_store_vect! with new obsolete date 
			
				rem --- Store New Item's Record With Effective Date			
					bmm02a.effect_date$=effectdate$; rem For new rec, set Effective
					bmm02a.obsolt_date$=FILL(3); rem For new rec, clear Obsolete
					bmm02a.item_id$=newitem$
					bmm02a.qty_required=bmm02a.qty_required*convertfact
					
					gosub add2vector; rem Add New 'replacement' item rec to bill_store_vect! 
					            
				rem --- Conditionally obsolete comments (memos) for this material line
				rem     (unlike materials, memos are not replaced, just obsoleted)
					if obsoletecmnts$="N" then continue

					while more
						do_bill_break=0; rem flag to break looping at bill change
						main_should_read=1; rem Haven't read BMM-02/moved ptr in this memo loop, so should read in main
			
						done_flag=1; rem Flag to stop all loops when End of file, range or Firm
						bmm02_key$=key(bmm02_dev,end=*break)
						done_flag=0
			
						if pos(firm_id$=bmm02_key$)<>1 then done_flag=1; break
						
						if curr_bill$<>bmm02_key.bill_no$ then 
							do_bill_break=1
							break
						endif
						       
						call pgmdir$+"adc_progress.aon","S","","","","",0,0,1,meter_num,ignore_status
		
						read record (bmm02_dev,key=bmm02_key$) bmm02a$
						gosub add2vector; rem Store each line of the whole bill in the bill_store_vect! 
						
						if bmm02a.line_type$<>"M" then 
							main_should_read=0; rem Flag that BMM-02 has been read, so don't re-read at top of main loop
							break
						endif
						if bmm02a.obsolt_date$<>fill(8) and bmm02a.obsolt_date$<=effectdate$ then continue
						if bmm02a.effect_date$<>fill(8) and bmm02a.effect_date$>effectdate$ then continue

						bmm02a.obsolt_date$=effectdate$; rem For Memos, leave Effective and set Obsolete
						gosub mod_vector; rem Update the memo line in the bill_store_vect! with new obsolete date 			
					wend
					if done_flag then break
					if do_bill_break then break
		
		wend; rem Individual bill loop
		If bill_was_changed gosub write_vector2file; rem Only write modified bills
		if done_flag then break
	wend; rem Main loop (all bills in range)	
		
rem --- Done Program

	goto std_exit

rem ================================================
rem             sub routines
rem ================================================

rem ------------------------------------------------
rem   add2vector
rem 
rem   Store bmm-02 rec/line for current bill in 
rem   bill_store_vect!
rem ------------------------------------------------
add2vector:
	bill_store_vect!.addItem(bmm02a$)
	recs_added=recs_added+1; rem NOTE: Equates to current vector elem since vector was forced to 1-based
return

rem ------------------------------------------------
rem   mod_vector
rem 
rem   Modify the date elements in bill_store_vect! for curr line/rec
rem     - For Memos and Old material, leave Effective and set Obsolete
rem     - For New material, Effective is set and Obsolete cleared via add2vector sub
rem ------------------------------------------------
mod_vector:
	bill_line$=bill_store_vect!.getItem(recs_added); rem Retrieve current line of Bill from vector
	
	bill_line.effect_date$=bmm02a.effect_date$; rem Change effective date for line in vector
	bill_line.obsolt_date$=bmm02a.obsolt_date$; rem Change obsolete date for line in vector
	
	bill_store_vect!.setItem(recs_added,bill_line$); rem Update vector rec with modified rec
	
	bill_was_changed=1; rem Set flag so that bill gets written back to bmm02
return

rem ------------------------------------------------
rem   write_vector2file
rem
rem   Write bill_store_vect! out to bmm-02
rem		note: vector made to be 1-based at top of pgm
rem ------------------------------------------------
write_vector2file:
    rem --- Delete bill from bmm02 (in case bmm02 is sequenced by >1)
		read(bmm02_dev,key=firm_id$+curr_bill$,dom=*next)
	
		while more
			bmm02_key$=key(bmm02_dev,end=*break)
				if pos(firm_id$=bmm02_key$)<>1 then break
				if bmm02_key.bill_no$<>curr_bill$ then break
				call pgmdir$+"adc_progress.aon","S","","","","",0,0,1,meter_num,ignore_status	
			remove (bmm02_dev,key=bmm02_key$)
		wend 
	
		tmp_seq=0; rem Can't use bmm02 seq cuz replace actually "inserts", so re-sequence

	rem --- Write recs from vector to bmm02 with re-sequence to increment by 1
		for vect_rec=1 to recs_added; rem note: vector is set to be 1-based
			tmp_seq=tmp_seq+1
			tmp_seq$=str(tmp_seq:"000")
        
			bmm02a$=bill_store_vect!.getItem(vect_rec)
			bmm02a.material_seq$=str(tmp_seq:"000")

			bmm02_key$=bmm02a.firm_id$+bmm02a.bill_no$+bmm02a.material_seq$
				
			write record (bmm02_dev) bmm02a$
		next vect_rec
return

rem ------------------------------------------------
rem    report_errors
rem 
rem    If errors, create DocOut report
rem ------------------------------------------------		
report_errors:
rem --- Headings

    h0=132
    h=0,headings=3,when$=sysinfo.system_date$,clock$=""
    dim headings$[headings],o[11],headline1$(h0),headline2$(h0)
    headings$[0]=sysinfo.firm_name$
    headings$[1]=sysinfo.task_desc$

    headings$[2]=Translate!.getTranslation("AON_FROM_")+Translate!.getTranslation("AON_BILL_NUMBER")+": "
		if billfrom$="" then
			headings$[2]=headings$[2]+Translate!.getTranslation("AON_FIRST")
		else 
			headings$[2]=headings$[2]+cvs(billfrom$,2)
		endif
		headings$[2]=headings$[2]+"   "+Translate!.getTranslation("AON_TO")+" "+Translate!.getTranslation("AON_BILL_NUMBER")+": "
		if billthru$="" then 
			headings$[2]=headings$[2]+Translate!.getTranslation("AON_LAST") 
		else 
			headings$[2]=headings$[2]+billthru$
		endif
    headings$[3]=Translate!.getTranslation("AON_REPLACE_ITEM")+
:                " "+cvs(olditem$,2)+
:                " "+Translate!.getTranslation("AON_WITH_ITEM")+
:                " "+cvs(newitem$,2)
    
rem ---  column heading
	item_desc_len=20
    columns=3
	dim columns$[columns,10]
        
    columns$[0,0]=Translate!.getTranslation("AON_BILL_NUMBER"),     columns$[0,1]="C",columns$[0,2]=str(p[0])
    columns$[1,0]=Translate!.getTranslation("AON_DESCRIPTION"),     columns$[1,1]="C",columns$[1,2]=str(item_desc_len)
    columns$[2,0]=Translate!.getTranslation("AON_SEQ"),             columns$[2,1]="C",columns$[2,2]="3"
    columns$[3,0]=Translate!.getTranslation("AON_MESSAGE"),         columns$[3,1]="C",columns$[3,2]="85"

rem --- Build OutVect! from error$ list

	OutVect!=bbjAPI().getSysGui().makeVector()
    HdrVect!=bbjAPI().getSysGui().makeVector()
    BrkVect!=bbjAPI().getSysGui().makeVector()
    TotVect!=bbjAPI().getSysGui().makeVector()
    rep_date$=date(0:"%Mz/%Dz/%Yd")
    rep_date_stamp$=date(0:"%Yd%Mz%Dz")
    rep_time$=date(0:"%hz:%mz %p")
    rep_time_stamp$=date(0:"%Hz%mz%sz")
    rep_prog$=pgm(-2)
	
    call pgmdir$+"adc_progress.aon","NC","","","","",p[0],bmm01_dev,1,meter_num,status
	
	for ptr=1 to len(error$) step err_seg_len	
		bill_no$=error$(ptr+1,item_len)
		bill_seq$=error$(ptr+item_len+1,seq_fld_len)
		
		x0$=firm_id$+bill_no$
		gosub find_desc			

		OutVect!.addItem(bill_no$(1,p[0]))
		OutVect!.addItem(ivdesc$)
		OutVect!.addItem(bill_seq$)
				
		if error$(ptr,1)="1" then 
			OutVect!.addItem(Translate!.getTranslation("AON_NO_AVAILABLE_SEQUENCE_NUMBERS_IN_THIS_BILL._MANUALLY_DELETE_LINES."))
        endif
		if error$(ptr,1)="2" then 
			OutVect!.addItem(Translate!.getTranslation("AON_CANNOT_REPLACE_COMPONENT_SINCE_IT_WOULD_BE_SAME_AS_BILL."))
		endif
	next ptr
		
	rem --- Print detail line
       
    xwk=fnblank(5)
    OutVect!.addItem(str(error_cnt)+Translate!.getTranslation("AON__ITEMS_LISTED"))
    xwk=fnblank(3)
	OutVect!.addItem(Translate!.getTranslation("AON_NO_BILLS_WERE_CHANGED.")+$00$+"B")
    xwk=fnblank(2)	
	goto std_exit_no_update
	
return

rem ------------------------------------------------
rem    find_desc
rem 
rem    Get bill's/item's description from item master 
rem ------------------------------------------------		
find_desc: rem --- Find Description & UnitCost
    dim ivdesc$(item_desc_len)

    ivm01a.item_desc$=Translate!.getTranslation("AON_***NOT_ON_FILE***")
    find record (ivm01_dev,key=x0$,dom=*next) ivm01a$
    ivdesc$(1)=fnitem$(ivm01a.item_desc$,desc[1],desc[2],desc[3])  
return

rem --- Functions

    def fncenter(q$,q)=int((q-len(q$))/2)

rem --- fnglobal$: Return string value of passed STBL variable

    def fnglobal$(q$,q1$)
        q1$=stbl(q$,err=globalstr_exit)
    globalstr_exit: 
        return q1$
    fnend

rem --- fnBlank : Create blank cells in OutVect!. No return value

    def fnblank(q0)
        for q1=1 to q0
            OutVect!.addItem("")
        next q1
        return q1
    fnend
	
rem #include std_functions.src
rem --- Standard AddonSoftware functions (01Mar2006)
rem --- Functions used to retrieve form values

    def fnstr_pos(q0$,q1$,q1)=int((pos(q0$=q1$,q1)+q1-1)/q1)
    def fnget_rec_date$(q0$)=rd_rec_data$[fnstr_pos(cvs(q0$,1+2+4)+"."+
:                            cvs(q0$,1+2+4),rd_rec_data$[0,0],40),0]
    def fnget_fld_data$(q0$,q1$)=cvs(rd_rec_data$[fnstr_pos(cvs(q0$,1+2+4)+"."+
:                                cvs(q1$,1+2+4),rd_rec_data$[0,0],40),0],2)
    def fnget_table$(q0$)=rd_alias_id$

rem --- Miscellaneous functions

    def fncenter(q$,q)=int((q-len(q$))/2)
    def fnqty(q1,q2,q3,q4,q5)=10000*q1*q2/(q3*q4*(100-q5))
    def fnop1(q1,q2,q3,q4,q5,q6)=100*(q1*q2/q3)/q4+q5*q2/q6
    def fnopqty(q1,q2,q3,q4,q5)=100*(q1/q2)/q3+q4/q5

rem --- Format inventory item description

	def fnitem$(q$,q1,q2,q3)
		q$=pad(q$,q1+q2+q3)
		return cvs(q$(1,q1)+" "+q$(q1+1,q2)+" "+q$(q1+q2+1,q3),32)
	fnend

rem --- Date/time handling functions

    def fnyy$(q$)=q$(3,2)
    def fnclock$(q$)=date(0:"%hz:%mz %p")
    def fntime$(q$)=date(0:"%Hz%mz")

rem --- fnmask$: Alphanumeric Masking Function (formerly fnf$)

    def fnmask$(q1$,q2$)
        if q2$="" q2$=fill(len(q1$),"0")
        return str(-num(q1$,err=*next):q2$,err=*next)
        q=1
        q0=0
        while len(q2$(q))
              if pos(q2$(q,1)="-()") q0=q0+1 else q2$(q,1)="X"
              q=q+1
        wend
        if len(q1$)>len(q2$)-q0 q1$=q1$(1,len(q2$)-q0)
        return str(q1$:q2$)
    fnend

rem --- fnbasename$: Strip path and optionally the suffix from a file name

    def fnbasename$(q$,q0$)
        q=max(pos("/"=q$,-1),pos(":"=q$,-1),pos(">"=q$,-1),pos("\"=q$,-1))
        if q then q$=q$(q+1)
        if q0$<>"" then q=mask(q$,q0$); if q q$=q$(1,q-1)
    return q$

rem --- fnglobal: Return numeric value of passed stbl variable

    def fnglobal(q$,q1)
        q1$=stbl(q$,err=*next),q1=num(q1$,err=*next)
        return q1
    fnend

rem --- fnglobal$: Return string value of passed STBL variable

    def fnglobal$(q$,q1$)
        q1$=stbl(q$,err=*next)
        return q1$
    fnend

rem --- fnBlank : Create blank cells in OutVect!. No return value
   
    def fnblank(q0)
        for q1=1 to q0
            OutVect!.addItem("")
        next q1
        return q1
    fnend

rem #endinclude std_functions.src	

disp_message: rem --- Display Message Dialog

    call stbl("+DIR_SYP")+"bac_message.bbj",msg_id$,msg_tokens$[all],msg_opt$,table_chans$[all]
    return

rem #include std_error.src

std_error: rem --- Standard error handler (22Feb2013)

    if tcb(19)>0
        rem --- Escape handler
        if and(chr(tcb(19)),$08$)=$08$
            release
        else
            setesc std_error
            return
        endif
    endif

    rd_err_text$=""
    if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
    call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err),rd_err_text$,rd_err_act$
    if pos("ESCAPE"=rd_err_act$) seterr 0; setesc 0
    if pos("RETRY"=rd_err_act$) retry
    if pgm(-1)<>pgm(-2) status=999; exit 
    release

rem #endinclude std_error.src
rem #include std_missing_params.src

std_missing_params: rem --- Standard missing parameter handler (15Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    pgmdir$=stbl("+DIR_PGM",err=std_missing_params_exit)
    call pgmdir$+"adc_noparams.aon",err=std_missing_params_exit,pgm(-2),str(tcb(5):"00000"),
:                                   str(err:"000"),rd_err_text$,rd_err_act$
std_missing_params_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_missing_params_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_missing_params_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_missing_params_release)
    sysinfo$=stbl("+SYSINFO",err=std_missing_params_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_missing_params_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_missing_params.src

rem #include std_end.src

std_exit: rem --- Standard program end (01Mar2006)

    msg_id$="UPDATE_COMPLETE"
    dim msg_tokens$[1]
    msg_opt$=""
    gosub disp_message

std_exit_no_update:

    call pgmdir$+"adc_progress.aon","D","","","","",0,0,0,meter_num,status
	out_action$="FORMAT"
    run stbl("+DIR_SYP")+"bas_process_end.bbj",err=*next
    release

rem #endinclude std_end.src

    end
